"""
Master Controller - Orchestrator for Plan-RAG Architecture
Coordinates Preprocessor -> Planner -> Experts -> Generator
Enhanced with Conversation Memory for progressive disclosure
"""

import time
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
from app.core import logger
from app.db import mongodb_manager


# Location highlights for GenUI responses
LOCATION_HIGHLIGHTS = {
    "ƒë√† n·∫µng": {
        "icon": "üèñÔ∏è",
        "tagline": "th√†nh ph·ªë bi·ªÉn xinh ƒë·∫πp",
        "highlights": "B√£i bi·ªÉn M·ªπ Kh√™, B√† N√† Hills, C·∫ßu R·ªìng",
        "tags": ["bi·ªÉn", "ngh·ªâ d∆∞·ª°ng", "·∫©m th·ª±c"]
    },
    "da nang": {
        "icon": "üèñÔ∏è",
        "tagline": "th√†nh ph·ªë bi·ªÉn xinh ƒë·∫πp",
        "highlights": "B√£i bi·ªÉn M·ªπ Kh√™, B√† N√† Hills, C·∫ßu R·ªìng",
        "tags": ["bi·ªÉn", "ngh·ªâ d∆∞·ª°ng", "·∫©m th·ª±c"]
    },
    "h·ªôi an": {
        "icon": "üèÆ",
        "tagline": "ph·ªë c·ªï lung linh",
        "highlights": "Ph·ªë c·ªï, ƒê√™m hoa ƒëƒÉng, Ch√πa C·∫ßu",
        "tags": ["vƒÉn h√≥a", "·∫©m th·ª±c", "may ƒëo"]
    },
    "hoi an": {
        "icon": "üèÆ",
        "tagline": "ph·ªë c·ªï lung linh",
        "highlights": "Ph·ªë c·ªï, ƒê√™m hoa ƒëƒÉng, Ch√πa C·∫ßu",
        "tags": ["vƒÉn h√≥a", "·∫©m th·ª±c", "may ƒëo"]
    },
    "nha trang": {
        "icon": "üåä",
        "tagline": "thi√™n ƒë∆∞·ªùng bi·ªÉn",
        "highlights": "Vinpearl, H√≤n Mun, Th√°p B√† Ponagar",
        "tags": ["bi·ªÉn", "l·∫∑n bi·ªÉn", "h·∫£i s·∫£n"]
    },
    "ph√∫ qu·ªëc": {
        "icon": "üèùÔ∏è",
        "tagline": "ƒë·∫£o ng·ªçc ph∆∞∆°ng Nam",
        "highlights": "Safari, Grand World, B√£i Sao",
        "tags": ["bi·ªÉn", "ngh·ªâ d∆∞·ª°ng", "thi√™n nhi√™n"]
    },
    "phu quoc": {
        "icon": "üèùÔ∏è",
        "tagline": "ƒë·∫£o ng·ªçc ph∆∞∆°ng Nam",
        "highlights": "Safari, Grand World, B√£i Sao",
        "tags": ["bi·ªÉn", "ngh·ªâ d∆∞·ª°ng", "thi√™n nhi√™n"]
    },
    "sapa": {
        "icon": "‚õ∞Ô∏è",
        "tagline": "th·ªã tr·∫•n m√π s∆∞∆°ng",
        "highlights": "Fansipan, B·∫£n C√°t C√°t, Ru·ªông b·∫≠c thang",
        "tags": ["n√∫i", "trekking", "vƒÉn h√≥a"]
    },
    "sa pa": {
        "icon": "‚õ∞Ô∏è",
        "tagline": "th·ªã tr·∫•n m√π s∆∞∆°ng",
        "highlights": "Fansipan, B·∫£n C√°t C√°t, Ru·ªông b·∫≠c thang",
        "tags": ["n√∫i", "trekking", "vƒÉn h√≥a"]
    },
    "hu·∫ø": {
        "icon": "üèõÔ∏è",
        "tagline": "c·ªë ƒë√¥ tri·ªÅu Nguy·ªÖn",
        "highlights": "ƒê·∫°i N·ªôi, Ch√πa Thi√™n M·ª•, LƒÉng T·ª± ƒê·ª©c",
        "tags": ["vƒÉn h√≥a", "l·ªãch s·ª≠", "·∫©m th·ª±c"]
    },
    "hue": {
        "icon": "üèõÔ∏è",
        "tagline": "c·ªë ƒë√¥ tri·ªÅu Nguy·ªÖn",
        "highlights": "ƒê·∫°i N·ªôi, Ch√πa Thi√™n M·ª•, LƒÉng T·ª± ƒê·ª©c",
        "tags": ["vƒÉn h√≥a", "l·ªãch s·ª≠", "·∫©m th·ª±c"]
    },
    "ƒë√† l·∫°t": {
        "icon": "üå∏",
        "tagline": "th√†nh ph·ªë ng√†n hoa",
        "highlights": "H·ªì Xu√¢n H∆∞∆°ng, ƒê·ªìi ch√®, Langbiang",
        "tags": ["n√∫i", "thi√™n nhi√™n", "l√£ng m·∫°n"]
    },
    "da lat": {
        "icon": "üå∏",
        "tagline": "th√†nh ph·ªë ng√†n hoa",
        "highlights": "H·ªì Xu√¢n H∆∞∆°ng, ƒê·ªìi ch√®, Langbiang",
        "tags": ["n√∫i", "thi√™n nhi√™n", "l√£ng m·∫°n"]
    },
    "h√† n·ªôi": {
        "icon": "üèôÔ∏è",
        "tagline": "th·ªß ƒë√¥ ng√†n nƒÉm vƒÉn hi·∫øn",
        "highlights": "Ph·ªë c·ªï, H·ªì G∆∞∆°m, VƒÉn Mi·∫øu",
        "tags": ["vƒÉn h√≥a", "l·ªãch s·ª≠", "·∫©m th·ª±c"]
    },
    "ha noi": {
        "icon": "üèôÔ∏è",
        "tagline": "th·ªß ƒë√¥ ng√†n nƒÉm vƒÉn hi·∫øn",
        "highlights": "Ph·ªë c·ªï, H·ªì G∆∞∆°m, VƒÉn Mi·∫øu",
        "tags": ["vƒÉn h√≥a", "l·ªãch s·ª≠", "·∫©m th·ª±c"]
    },
    "h·ªì ch√≠ minh": {
        "icon": "üåÜ",
        "tagline": "th√†nh ph·ªë kh√¥ng ng·ªß",
        "highlights": "Dinh ƒê·ªôc L·∫≠p, B·∫øn Nh√† R·ªìng, Ph·ªë ƒëi b·ªô",
        "tags": ["ƒë√¥ th·ªã", "·∫©m th·ª±c", "mua s·∫Øm"]
    },
    "default": {
        "icon": "üåü",
        "tagline": "ƒëi·ªÉm ƒë·∫øn h·∫•p d·∫´n",
        "highlights": "Nhi·ªÅu ƒë·ªãa ƒëi·ªÉm tham quan th√∫ v·ªã",
        "tags": ["kh√°m ph√°", "ngh·ªâ d∆∞·ª°ng"]
    }
}


# Keep legacy ConversationContext for backward compatibility
@dataclass
class ConversationContext:
    """Tracks conversation state (legacy)"""
    destination: Optional[str] = None
    duration: Optional[int] = None
    budget: Optional[int] = None
    budget_level: Optional[str] = None
    people_count: int = 1
    interests: List[str] = field(default_factory=list)
    last_intent: Optional[str] = None
    selected_hotel: Optional[str] = None
    selected_hotel_price: Optional[int] = None
    itinerary: List[Dict] = field(default_factory=list)
    itinerary_builder: Optional[Dict] = None  # For interactive itinerary building
    
    def update_from_intent(self, intent):
        """Update context from ExtractedIntent"""
        if intent.location:
            self.destination = intent.location
        if intent.duration:
            self.duration = intent.duration
        if intent.budget:
            self.budget = intent.budget
        if intent.budget_level:
            self.budget_level = intent.budget_level
        if intent.people_count and intent.people_count > 0:
            self.people_count = intent.people_count
        if intent.interests:
            self.interests = intent.interests
        self.last_intent = intent.intent
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "destination": self.destination,
            "duration": self.duration,
            "budget": self.budget,
            "budget_level": self.budget_level,
            "people_count": self.people_count,
            "interests": self.interests,
            "last_intent": self.last_intent,
            "selected_hotel": self.selected_hotel,
            "selected_hotel_price": self.selected_hotel_price,
            "itinerary_builder": self.itinerary_builder
        }


def _clean_mongo_doc(doc: dict) -> dict:
    """Clean MongoDB document for JSON serialization
    
    Converts ObjectId and datetime to strings
    """
    if not doc:
        return doc
    
    from datetime import datetime
    from bson import ObjectId
    
    cleaned = {}
    for key, value in doc.items():
        if isinstance(value, ObjectId):
            cleaned[key] = str(value)
        elif isinstance(value, datetime):
            cleaned[key] = value.isoformat()
        elif isinstance(value, dict):
            cleaned[key] = _clean_mongo_doc(value)
        elif isinstance(value, list):
            cleaned[key] = [
                _clean_mongo_doc(item) if isinstance(item, dict) else 
                str(item) if isinstance(item, (ObjectId, datetime)) else item
                for item in value
            ]
        else:
            cleaned[key] = value
    return cleaned


class MasterController:
    """
    Master Controller for Plan-RAG Architecture
    
    Flow:
    1. Preprocess: Extract intent, entities, constraints
    2. Plan: Decompose into sub-tasks
    3. Execute: Run expert executors in parallel/sequence
    4. Aggregate: Combine results
    5. Generate: Create final response
    """
    
    def __init__(self):
        # Ensure MongoDB is connected
        if mongodb_manager.db is None:
            mongodb_manager.connect()
        
        # Store MongoDB manager reference for booking etc.
        self.mongo_manager = mongodb_manager
        
        # Initialize LLM client
        try:
            from app.services.llm_client import llm_client
            self.llm = llm_client
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è LLM client not available: {e}")
            self.llm = None
        
        # Initialize base intent extractor
        from app.services.intent_extractor import create_intent_extractor
        base_intent_extractor = create_intent_extractor(self.llm)
        
        # Initialize multi-intent extractor (wraps base extractor)
        from app.services.multi_intent_extractor import create_multi_intent_extractor
        self.multi_intent_extractor = create_multi_intent_extractor(base_intent_extractor)
        self.intent_extractor = base_intent_extractor  # Backward compatibility
        
        # Initialize base planner
        from app.services.planner_agent import create_planner_agent
        base_planner = create_planner_agent(self.llm)
        
        # Initialize multi-planner (wraps base planner)
        from app.services.multi_planner_agent import create_multi_planner_agent
        self.multi_planner = create_multi_planner_agent(base_planner)
        self.planner = base_planner  # Backward compatibility
        
        # Initialize response aggregator
        from app.services.response_aggregator import create_response_aggregator
        self.response_aggregator = create_response_aggregator(self.llm)
        
        # Initialize conversation memory manager
        from app.services.conversation_memory import create_conversation_memory_manager, EnhancedConversationContext
        self.memory_manager = create_conversation_memory_manager(self.llm)
        self.EnhancedConversationContext = EnhancedConversationContext
        
        # Initialize embedding service for semantic search
        try:
            from app.services.embedding_service import create_embedding_service
            self.embedding_service = create_embedding_service()
            logger.info("‚úÖ Embedding service initialized")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è  Embedding service not available: {e}")
            self.embedding_service = None
        
        # Initialize experts
        from app.services.experts import (
            SpotExpert, HotelExpert, FoodExpert, 
            ItineraryExpert, CostCalculatorExpert, GeneralInfoExpert
        )
        
        self.experts = {
            "find_spots": SpotExpert(mongodb_manager, None, self.llm, self.embedding_service),
            "find_hotels": HotelExpert(mongodb_manager, None, self.llm),
            "find_food": FoodExpert(mongodb_manager, None, self.llm),
            "create_itinerary": ItineraryExpert(mongodb_manager, None, self.llm),
            "calculate_cost": CostCalculatorExpert(mongodb_manager, None, self.llm),
            "general_info": GeneralInfoExpert(mongodb_manager, self.llm)
        }
        
        # ============================================================
        # STATE MACHINE: Intent Dependencies (StateGuard Matrix)
        # Ch·∫∑n ƒë·ª©ng c√°c Intent "nh·∫£y b∆∞·ªõc" ƒë·ªÉ duy tr√¨ lu·ªìng tuy·∫øn t√≠nh
        # ============================================================
        self.INTENT_DEPENDENCIES = {
            "calculate_cost": {
                "required_states": ["CHOOSING_HOTEL", "READY_TO_FINALIZE"],
                "required_fields": ["selected_hotel"],
                "error_action": "prompt_hotel",
                "error_msg": "üè® B·∫°n ∆°i, m√¨nh c·∫ßn ch·ªët kh√°ch s·∫°n tr∆∞·ªõc th√¨ m·ªõi t√≠nh t·ªïng chi ph√≠ ch√≠nh x√°c ƒë∆∞·ª£c ·∫°!\n\nüí° G√µ **'t√¨m kh√°ch s·∫°n'** ƒë·ªÉ xem danh s√°ch."
            },
            "find_hotel": {
                "required_states": ["CHOOSING_HOTEL", "CHOOSING_SPOTS", "INITIAL"],
                "required_fields": ["destination"],
                "error_action": "prompt_destination",
                "error_msg": "üìç B·∫°n mu·ªën t√¨m kh√°ch s·∫°n ·ªü ƒë√¢u? Cho m√¨nh bi·∫øt ƒëi·ªÉm ƒë·∫øn nh√©!"
            },
            "find_food": {
                "required_states": ["CHOOSING_HOTEL", "CHOOSING_SPOTS", "INITIAL", "READY_TO_FINALIZE"],
                "required_fields": ["destination"],
                "error_action": "prompt_destination", 
                "error_msg": "üìç B·∫°n mu·ªën t√¨m qu√°n ƒÉn ·ªü ƒë√¢u? Cho m√¨nh bi·∫øt ƒë·ªãa ƒëi·ªÉm nh√©!"
            }
        }
        
        # Priority order for task execution (Pipeline tuy·∫øn t√≠nh)
        self.TASK_PRIORITY_ORDER = ["spots", "hotels", "food", "itinerary", "cost"]
        
        logger.info("‚úÖ MasterController initialized with enhanced multi-intent Plan-RAG + Conversation Memory + Semantic Search")
    
    def process_request(
        self,
        messages: List[Dict[str, str]],
        context: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Process user request through Plan-RAG pipeline with progressive disclosure
        
        Args:
            messages: List of {"role": "user"|"assistant", "content": "..."}
            context: Optional conversation context
            
        Returns:
            Response dict with reply, ui_type, ui_data, context
        """
        start_time = time.time()
        
        try:
            # Get last user message
            user_message = self._get_last_user_message(messages)
            if not user_message:
                return self._error_response("Kh√¥ng nh·∫≠n ƒë∆∞·ª£c tin nh·∫Øn")
            
            # Initialize/restore enhanced context
            enhanced_context = self._restore_enhanced_context(context)
            
            # Add user message to history
            enhanced_context.add_message("user", user_message)
            
            logger.info(f"üì• Processing: {user_message[:50]}...")
            
            # === PHASE 1: PREPROCESS - Multi-Intent Extraction ===
            multi_intent = self.multi_intent_extractor.extract(
                user_message, 
                enhanced_context.to_dict()
            )
            
            all_intents = [multi_intent.primary_intent] + multi_intent.sub_intents
            logger.info(f"üéØ Intents detected: {all_intents} | Location: {multi_intent.location}")
            
            # Update context from primary intent
            extracted_intent = multi_intent.to_extracted_intent()
            enhanced_context.update_from_intent(extracted_intent)
            
            # === PHASE 1.5: FLOW CONTROL - Ch·∫∑n Greedy Execution ===
            # NGUY√äN T·∫ÆC: State-First, Intent-Second
            state = enhanced_context.workflow_state
            logger.info(f"üîÑ Flow Control Check: State={state}, Primary Intent={multi_intent.primary_intent}")
            
            # RULE 1: N·∫øu ƒëang trong Interactive Itinerary Builder ‚Üí KH√ìA v√†o lu·ªìng n√†y
            if enhanced_context.itinerary_builder or state in ["CHOOSING_SPOTS", "GATHERING_INFO"]:
                # Ch·∫∑n c√°c intent l√†m nhi·ªÖu (find_hotel, find_food t·ª± ƒë·ªông)
                if multi_intent.primary_intent in ["find_spot", "plan_trip", "general_qa"]:
                    logger.info(f"üîí Flow locked to itinerary builder")
                    special_response = self._handle_special_intent_sync(
                        multi_intent, enhanced_context, user_message
                    )
                    if special_response:
                        execution_time = int((time.time() - start_time) * 1000)
                        special_response["execution_time_ms"] = execution_time
                        special_response["context"] = enhanced_context.to_dict()
                        return special_response
                    
            # RULE 2: N·∫øu primary_intent = plan_trip v√† state = INITIAL ‚Üí CH·ªà ch·∫°y builder
            # TUY·ªÜT ƒê·ªêI KH√îNG cho ph√©p find_hotel hay find_food ch·∫°y ƒë·ªìng th·ªùi
            if multi_intent.primary_intent == "plan_trip" and state == "INITIAL":
                # Lo·∫°i b·ªè t·∫•t c·∫£ sub_intents hotel/food t·ª± ƒë·ªông
                original_sub_intents = multi_intent.sub_intents.copy()
                multi_intent.sub_intents = [
                    intent for intent in multi_intent.sub_intents 
                    if intent not in ["find_hotel", "find_food"]
                ]
                if original_sub_intents != multi_intent.sub_intents:
                    logger.warning(f"üö´ Blocked greedy execution: Removed {set(original_sub_intents) - set(multi_intent.sub_intents)}")
            
            # RULE 3: N·∫øu state = CHOOSING_HOTEL ‚Üí KH√îNG cho ph√©p find_food t·ª± ƒë·ªông
            if state == "CHOOSING_HOTEL":
                # Ch·ªâ cho ph√©p find_food n·∫øu user y√™u c·∫ßu ƒê√çCH DANH
                if "find_food" in multi_intent.sub_intents and not any(kw in user_message.lower() for kw in ["qu√°n ƒÉn", "m√≥n ƒÉn", "food", "nh√† h√†ng"]):
                    multi_intent.sub_intents.remove("find_food")
                    logger.warning(f"üö´ Blocked auto find_food in CHOOSING_HOTEL state")
            
            # === PHASE 1.6: HANDLE SPECIAL INTENTS (sync version) ===
            special_response = self._handle_special_intent_sync(
                multi_intent, enhanced_context, user_message
            )
            if special_response:
                execution_time = int((time.time() - start_time) * 1000)
                special_response["execution_time_ms"] = execution_time
                special_response["context"] = enhanced_context.to_dict()
                logger.info(f"‚úÖ Special intent handled in {execution_time}ms")
                return special_response
            
            # === PHASE 2: PLAN - Multi-Intent Planning ===
            plan = self.multi_planner.plan(multi_intent)
            
            logger.info(f"üìã Execution plan: {len(plan.tasks)} tasks ‚Üí {plan.execution_order}")
            
            # === PHASE 3: EXECUTE ===
            results = self._execute_plan(plan, original_query=user_message)
            
            # === PHASE 4: AGGREGATE ===
            aggregated = self._aggregate_results(results)
            
            # Store results in context for follow-up queries
            if aggregated.get("spots"):
                enhanced_context.update_last_spots(aggregated["spots"])
            if aggregated.get("hotels"):
                enhanced_context.update_last_hotels(aggregated["hotels"])
            if aggregated.get("food"):
                enhanced_context.update_last_foods(aggregated["food"])
            if aggregated.get("itinerary"):
                enhanced_context.update_last_itinerary({"days": aggregated["itinerary"]})
            
            # === PHASE 5: PROGRESSIVE RESPONSE GENERATION ===
            # Check what we can answer vs what we need to defer
            progressive_info = self.memory_manager.create_progressive_response(
                multi_intent,
                aggregated,
                enhanced_context
            )
            
            answered_sections = progressive_info["answered_sections"]
            unanswered_intents = progressive_info["unanswered_intents"]
            has_partial = progressive_info["has_partial_answer"]
            
            logger.info(f"üìä Response: {len(answered_sections)} sections answered, {len(unanswered_intents)} deferred")
            
            # Build progressive reply
            if has_partial or len(answered_sections) > 0:
                # We have at least something to answer
                reply = self.memory_manager.build_progressive_reply(
                    answered_sections=answered_sections,
                    unanswered_intents=unanswered_intents,
                    results=aggregated,
                    location=multi_intent.location or enhanced_context.destination or "khu v·ª±c n√†y",
                    context=enhanced_context
                )
                
                # Determine UI type based on what we answered
                ui_type = self._determine_ui_type(answered_sections, aggregated)
                ui_data = self._build_ui_data(answered_sections, aggregated)
                
            else:
                # Nothing to answer - need clarification
                reply = self._generate_clarification_request(
                    multi_intent,
                    unanswered_intents,
                    enhanced_context
                )
                ui_type = "options"
                ui_data = self._generate_clarification_options(enhanced_context)
            
            # Add assistant message to history
            enhanced_context.add_message("assistant", reply[:200])  # Store truncated version
            
            # Build final response
            response = {
                "reply": reply,
                "ui_type": ui_type,
                "ui_data": ui_data,
                "intent": multi_intent.primary_intent,
                "intents": all_intents,
                "answered_sections": answered_sections,
                "unanswered_count": len(unanswered_intents)
            }
            
            # Add timing
            execution_time = int((time.time() - start_time) * 1000)
            response["execution_time_ms"] = execution_time
            response["context"] = enhanced_context.to_dict()
            
            logger.info(f"‚úÖ Response generated in {execution_time}ms")
            
            return response
            
        except Exception as e:
            logger.error(f"‚ùå MasterController error: {e}")
            import traceback
            traceback.print_exc()
            return self._error_response(str(e))
    
    async def process_stream(
        self,
        messages: List[Dict[str, str]],
        context: Dict[str, Any] = None
    ):
        """
        Process request with streaming - yield results as they become available
        
        Progressive flow:
        1. Handle special intents (greeting, chitchat, booking) first
        2. Find spots ‚Üí Yield immediately
        3. Find hotels ‚Üí Yield next
        4. Generate itinerary ‚Üí Yield next
        5. Calculate cost ‚Üí Yield final
        
        Args:
            messages: Conversation messages
            context: Optional context
            
        Yields:
            Dict chunks with reply, ui_type, ui_data, status
        """
        try:
            logger.info("üì° Starting streaming process...")
            
            # Extract user message
            user_message = self._get_last_user_message(messages)
            if not user_message:
                yield {"error": "No user message found", "reply": "B·∫°n mu·ªën h·ªèi g√¨?", "ui_type": "none"}
                return
            
            # Phase 1: Extract intent (FAST - no streaming needed)
            logger.info(f"üì• Processing: {user_message[:50]}...")
            
            # Initialize/restore enhanced context
            enhanced_context = self._restore_enhanced_context(context)
            enhanced_context.add_message("user", user_message)
            
            # Extract multi-intent
            multi_intent = self.multi_intent_extractor.extract(
                user_message,
                enhanced_context.to_dict()
            )
            
            logger.info(f"üéØ Detected intent: {multi_intent.primary_intent} (confidence: {multi_intent.confidence})")
            
            # ============================================================
            # üî• CRITICAL: Check SPECIAL INTENTS BEFORE workflow state logic
            # Special intents (show_itinerary, calculate_cost, book_hotel) should bypass state checks
            # ============================================================
            intent = multi_intent.primary_intent
            
            # === SHOW ITINERARY: Recall from memory (HIGHEST PRIORITY) ===
            if intent == "show_itinerary":
                logger.info("üîç [STREAMING] show_itinerary detected - recalling from memory")
                recall_response = self._handle_recall_itinerary(enhanced_context)
                if recall_response:
                    yield recall_response
                    yield {"reply": "", "status": "complete", "ui_type": "none", "context": enhanced_context.to_dict()}
                    return
            
            # === CALCULATE COST: Estimate budget ===
            if intent == "calculate_cost":
                logger.info("üí∞ [STREAMING] calculate_cost detected - estimating costs")
                cost_response = self._handle_cost_calculation_sync(multi_intent, enhanced_context, user_message)
                if cost_response:
                    yield cost_response
                    yield {"reply": "", "status": "complete", "ui_type": "none", "context": enhanced_context.to_dict()}
                    return
            
            # === BOOK HOTEL: Confirm booking ===
            if intent == "book_hotel":
                logger.info("üè® [STREAMING] book_hotel detected - confirming reservation")
                booking_response = self._handle_book_hotel_sync(multi_intent, enhanced_context)
                if booking_response:
                    yield booking_response
                    yield {"reply": "", "status": "complete", "ui_type": "none", "context": enhanced_context.to_dict()}
                    return
            
            # ============================================================
            # üß† FLOW CONTROL: State-First, Intent-Second
            # Ki·ªÉm tra workflow_state TR∆Ø·ªöC KHI th·ª±c thi Intent
            # ============================================================
            current_state = getattr(enhanced_context, 'workflow_state', 'INITIAL')
            is_backtrack = self._is_backtrack_signal(user_message)
            logger.info(f"üîÑ Current State: {current_state}")
            logger.info(f"üîÑ Is backtrack signal: {is_backtrack}")
            logger.info(f"üîÑ Context keys: {list(context.keys()) if context else 'None'}")
            
            # CASE 0: BACKTRACK - User mu·ªën quay l·∫°i ch·ªânh s·ª≠a sau khi ƒë√£ finalize
            # Ph·∫£i check TR∆Ø·ªöC CASE A v√¨ builder c√≥ th·ªÉ ƒë√£ b·ªã x√≥a
            if current_state == "CHOOSING_HOTEL" and is_backtrack:
                logger.info(f"üîô BACKTRACK detected! User wants to modify spots while in CHOOSING_HOTEL")
                
                # N·∫øu builder ƒë√£ b·ªã x√≥a (do finalize), kh√¥i ph·ª•c t·ª´ last_itinerary
                if not enhanced_context.itinerary_builder and enhanced_context.last_itinerary:
                    logger.info(f"üîÑ Rebuilding builder from last_itinerary...")
                    enhanced_context.itinerary_builder = self._rebuild_builder_from_last(
                        enhanced_context.last_itinerary,
                        enhanced_context
                    )
                    
                # Chuy·ªÉn state v·ªÅ CHOOSING_SPOTS
                enhanced_context.workflow_state = "CHOOSING_SPOTS"
                logger.info(f"‚úÖ State changed: CHOOSING_HOTEL ‚Üí CHOOSING_SPOTS")
                
                # Route ƒë·∫øn builder handler
                builder_response = self._continue_interactive_itinerary_sync(user_message, enhanced_context)
                if builder_response:
                    yield builder_response
                    yield {"reply": "", "status": "complete", "ui_type": "none", "context": enhanced_context.to_dict()}
                    return
            
            # CASE A: ƒêang trong Interactive Builder ‚Üí ∆Øu ti√™n gi·ªØ user ·ªü builder
            if self._should_stay_in_builder(multi_intent, enhanced_context, user_message):
                logger.info(f"üìå User is in builder (state={current_state}), routing to builder handler")
                
                # Ki·ªÉm tra flow_action t·ª´ LLM (finalize, continue, back)
                flow_action = getattr(multi_intent, 'flow_action', None)
                
                if flow_action == "finalize" or self._is_finalize_signal(user_message):
                    # User n√≥i "xong" ‚Üí Finalize current step
                    finalize_response = self._finalize_interactive_itinerary_sync(enhanced_context)
                    yield finalize_response
                    # NO completion signal - let frontend continue conversation
                    return
                else:
                    # Ti·∫øp t·ª•c trong builder (ch·ªçn s·ªë, h·ªèi th√™m ƒë·ªãa ƒëi·ªÉm, etc.)
                    yield self._continue_interactive_itinerary_sync(user_message, enhanced_context)
                    yield {"reply": "", "status": "complete", "ui_type": "none", "context": enhanced_context.to_dict()}
                    return
            
            # CASE B: StateGuard - L·ªçc Intent b·ªã ch·∫∑n do thi·∫øu ƒëi·ªÅu ki·ªán
            valid_intents, blocked_reasons = self._validate_intent_flow(multi_intent, enhanced_context)
            
            if blocked_reasons and not valid_intents:
                # T·∫•t c·∫£ intents b·ªã ch·∫∑n ‚Üí Tr·∫£ v·ªÅ h∆∞·ªõng d·∫´n
                guard_response = self._generate_state_guard_response(blocked_reasons, enhanced_context)
                if guard_response:
                    yield guard_response
                    yield {"reply": "", "status": "complete", "ui_type": "none", "context": enhanced_context.to_dict()}
                    return
            
            # C·∫≠p nh·∫≠t intents ƒë√£ l·ªçc
            if blocked_reasons:
                logger.info(f"üö´ StateGuard filtered: {[b['intent'] for b in blocked_reasons]}")
                # Update MultiIntent: set primary_intent and sub_intents from valid_intents
                if valid_intents:
                    multi_intent.primary_intent = valid_intents[0]
                    multi_intent.sub_intents = valid_intents[1:]
            
            # CASE C: B·∫Øt ƒë·∫ßu Interactive Builder m·ªõi (plan_trip t·ª´ INITIAL)
            if multi_intent.primary_intent == "plan_trip" and current_state == "INITIAL":
                if multi_intent.location and multi_intent.duration:
                    logger.info(f"üóìÔ∏è Starting new interactive itinerary: {multi_intent.location} x {multi_intent.duration} days")
                    yield self._start_interactive_itinerary_sync(
                        multi_intent.location, 
                        multi_intent.duration, 
                        enhanced_context
                    )
                    yield {"reply": "", "status": "complete", "ui_type": "none", "context": enhanced_context.to_dict()}
                    return
            
            # ============================================================
            # END FLOW CONTROL - Continue with normal processing below
            # ============================================================
            
            # === HANDLE "MORE" REQUESTS FIRST ===
            # When user asks for more spots/hotels/food, directly execute fresh search
            if multi_intent.keywords and "more" in multi_intent.keywords:
                logger.info(f"üîÑ Handling 'MORE' request for {multi_intent.primary_intent}")
                more_response = await self._handle_more_request(
                    multi_intent, enhanced_context, user_message
                )
                if more_response:
                    yield more_response
                    yield {
                        "reply": "",
                        "status": "complete",
                        "ui_type": "none",
                        "context": enhanced_context.to_dict()
                    }
                    return
            
            # === PRIORITY CHECK: Customize itinerary per day ===
            # This must be checked BEFORE regular intent handling
            day_preferences = self._parse_day_preferences(user_message)
            if day_preferences:
                logger.info(f"üóìÔ∏è Detected day preferences: {day_preferences}")
                customize_response = await self._handle_customize_itinerary(
                    day_preferences, enhanced_context, multi_intent
                )
                if customize_response:
                    yield customize_response
                    yield {
                        "reply": "",
                        "status": "complete",
                        "ui_type": "none",
                        "context": enhanced_context.to_dict()
                    }
                    return
            
            # === SMART HANDLER: Check for special intents first ===
            special_response = await self._handle_special_intent(
                multi_intent, enhanced_context, user_message
            )
            if special_response:
                yield special_response
                yield {
                    "reply": "",
                    "status": "complete",
                    "ui_type": "none",
                    "context": enhanced_context.to_dict()
                }
                return
            
            # === SMART CONVERSATION: Check if we need more info before planning ===
            info_gathering_response = await self._check_info_gathering_needed(
                multi_intent, enhanced_context, user_message
            )
            if info_gathering_response:
                yield info_gathering_response
                yield {
                    "reply": "",
                    "status": "complete",
                    "ui_type": "none",
                    "context": enhanced_context.to_dict()
                }
                return
            
            # Update context from primary intent
            extracted_intent = multi_intent.to_extracted_intent()
            enhanced_context.update_from_intent(extracted_intent)
            
            # === IMPORTANT: Merge context back into multi_intent for planning ===
            # If user says "ƒëi 3 ng√†y" without location, use context's destination
            if not multi_intent.location and enhanced_context.destination:
                logger.info(f"üìç Using context destination: {enhanced_context.destination}")
                multi_intent.location = enhanced_context.destination
            if not multi_intent.duration and enhanced_context.duration:
                logger.info(f"‚è±Ô∏è Using context duration: {enhanced_context.duration}")
                multi_intent.duration = enhanced_context.duration
            if not multi_intent.budget and enhanced_context.budget:
                logger.info(f"üí∞ Using context budget: {enhanced_context.budget}")
                multi_intent.budget = enhanced_context.budget
            
            # Phase 2: Create plan
            plan = self.multi_planner.plan(multi_intent)
            
            # Phase 3: Execute plan WITH STREAMING
            # Group tasks by type for progressive delivery
            # PASS enhanced_context for Anti-Greedy filtering
            task_groups = self._group_tasks_for_streaming(plan.tasks, enhanced_context)
            logger.info(f"üìä Task groups: {list(task_groups.keys())} ({sum(len(t) for t in task_groups.values())} total tasks)")
            
            if not task_groups:
                # No tasks created - use smart fallback
                logger.warning("‚ö†Ô∏è No task groups created - using smart fallback")
                fallback_response = await self._create_smart_fallback(
                    user_message, multi_intent, enhanced_context
                )
                yield fallback_response
                yield {
                    "reply": "",
                    "status": "complete",
                    "ui_type": "none",
                    "context": enhanced_context.to_dict()
                }
                return
            
            aggregated_all = {
                "spots": [],
                "hotels": [],
                "food": [],
                "itinerary": [],
                "costs": {}
            }
            
            # ============================================================
            # PRIORITY BREAK MODE: Ch·ªâ th·ª±c thi 1 group ∆∞u ti√™n
            # ƒë·ªÉ tr√°nh ƒë·ªï UI √†o ·∫°t (Greedy Execution)
            # ============================================================
            priority_break_mode = current_state in ["INITIAL", "CHOOSING_SPOTS", "CHOOSING_HOTEL"]
            executed_primary_group = False
            
            for group_name, tasks in task_groups.items():
                logger.info(f"üîÑ Processing group: {group_name} ({len(tasks)} tasks)")
                
                # Execute this group - PASS AGGREGATED DATA for dependencies!
                group_results = self._execute_plan_subset(tasks, user_message, aggregated_all)
                
                # Aggregate group results
                group_aggregated = self._aggregate_results(group_results)
                logger.info(f"   Aggregated: {list(group_aggregated.keys())} - has data: {any(group_aggregated.values())}")
                
                # Merge into total
                for key in aggregated_all.keys():
                    if key in group_aggregated:
                        if isinstance(group_aggregated[key], list):
                            aggregated_all[key].extend(group_aggregated[key])
                        elif isinstance(group_aggregated[key], dict):
                            aggregated_all[key].update(group_aggregated[key])
                
                # Store results in context for follow-up queries
                if group_aggregated.get("spots"):
                    enhanced_context.update_last_spots(group_aggregated["spots"])
                if group_aggregated.get("hotels"):
                    enhanced_context.update_last_hotels(group_aggregated["hotels"])
                if group_aggregated.get("food"):
                    enhanced_context.update_last_foods(group_aggregated["food"])
                if group_aggregated.get("itinerary"):
                    enhanced_context.update_last_itinerary({"days": group_aggregated["itinerary"]})
                if group_aggregated.get("costs"):
                    enhanced_context.update_last_cost(group_aggregated["costs"])
                
                # Only yield if this group has meaningful data
                if group_aggregated and any(group_aggregated.values()):
                    # For streaming: create section-specific response, not full aggregate
                    # Determine which section to format based on group name
                    section_response = self._format_group_section(
                        group_name,
                        group_aggregated,
                        multi_intent,
                        enhanced_context
                    )
                    
                    if section_response:
                        # Add streaming metadata
                        section_response["status"] = "partial"
                        section_response["group"] = group_name
                        section_response["progress"] = f"{group_name} complete"
                        section_response["workflow_state"] = current_state
                        
                        # Yield this chunk
                        yield section_response
                        executed_primary_group = True
                        
                        # =====================================================
                        # üõë PRIORITY BREAK: D·ª´ng sau khi g·ª≠i 1 UI Component
                        # ƒë·ªÉ gi·ªØ lu·ªìng d·∫´n d·∫Øt, tr√°nh ƒë·ªï hotel+food+cost c√πng l√∫c
                        # =====================================================
                        if priority_break_mode:
                            logger.info(f"üõë Priority Break: Stopping after {group_name} to guide user")
                            break
                            
                # Don't yield empty groups to reduce overhead
            
            # Final summary - ALWAYS yield to signal completion
            final_response = {
                "reply": "‚úÖ ƒê√£ ho√†n t·∫•t t·∫•t c·∫£ th√¥ng tin!" if not priority_break_mode else "",
                "ui_type": "none",
                "status": "complete",
                "context": enhanced_context.to_dict()
            }
            yield final_response
            
        except Exception as e:
            logger.error(f"‚ùå Streaming error: {e}", exc_info=True)
            yield {
                "error": str(e),
                "reply": "‚ö†Ô∏è Xin l·ªói, c√≥ l·ªói x·∫£y ra.",
                "ui_type": "none",
                "status": "error"
            }
    
    def _group_tasks_for_streaming(self, tasks: List, enhanced_context=None) -> Dict[str, List]:
        """
        Group tasks by type for progressive delivery.
        
        REFACTORED: Nh√≥m theo Pipeline du l·ªãch v√† filter d·ª±a tr√™n workflow_state
        ƒë·ªÉ tr√°nh Greedy Execution (ƒë·ªï UI √†o ·∫°t).
        
        Pipeline: discovery -> itinerary_build -> accommodation -> dining -> finance
        
        Returns:
            OrderedDict with tasks grouped by travel pipeline stage
        """
        from collections import OrderedDict
        
        # Nh√≥m theo giai ƒëo·∫°n du l·ªãch (kh√¥ng ch·ªâ theo lo·∫°i k·ªπ thu·∫≠t)
        groups = OrderedDict([
            ("discovery", []),      # T√¨m ƒëi·ªÉm ƒë·∫øn, intro v√πng mi·ªÅn
            ("spots", []),          # C√°c task li√™n quan ƒë·∫øn ch·ªçn spot
            ("hotels", []),         # T√¨m kh√°ch s·∫°n
            ("food", []),           # T√¨m qu√°n ƒÉn
            ("itinerary", []),      # T·∫°o l·ªãch tr√¨nh
            ("cost", [])            # T√≠nh to√°n chi ph√≠
        ])
        
        for task in tasks:
            tid = task.task_id.lower()
            
            # √Ånh x·∫° task v√†o ƒë√∫ng giai ƒëo·∫°n
            if any(x in tid for x in ["spots_", "general_info", "discover"]):
                groups["spots"].append(task)
            elif "hotel_" in tid:
                groups["hotels"].append(task)
            elif "food_" in tid:
                groups["food"].append(task)
            elif "itinerary_" in tid:
                groups["itinerary"].append(task)
            elif "cost_" in tid:
                groups["cost"].append(task)
            else:
                groups["discovery"].append(task)
        
        # Lo·∫°i b·ªè groups r·ªóng
        groups = OrderedDict((k, v) for k, v in groups.items() if v)
        
        # ============================================================
        # ANTI-GREEDY FILTER: Ch·ªâ gi·ªØ l·∫°i group ph√π h·ª£p v·ªõi workflow_state
        # ============================================================
        if enhanced_context:
            current_state = getattr(enhanced_context, 'workflow_state', 'INITIAL')
            
            # N·∫øu ƒëang ch·ªçn spots, ch·∫∑n hotels/food/cost
            if current_state == "CHOOSING_SPOTS":
                allowed_groups = ["discovery", "spots"]
                groups = OrderedDict((k, v) for k, v in groups.items() if k in allowed_groups)
                logger.info(f"üéØ Anti-Greedy: Filtered to {list(groups.keys())} for state {current_state}")
            
            # N·∫øu ƒëang ch·ªçn hotel, ch·∫∑n cost
            elif current_state == "CHOOSING_HOTEL":
                allowed_groups = ["hotels", "discovery", "spots"]  # Cho ph√©p backtrack
                groups = OrderedDict((k, v) for k, v in groups.items() if k in allowed_groups)
                logger.info(f"üéØ Anti-Greedy: Filtered to {list(groups.keys())} for state {current_state}")
        
        return groups
    
    def _format_group_section(
        self,
        group_name: str,
        group_data: Dict[str, Any],
        multi_intent,
        context
    ) -> Optional[Dict[str, Any]]:
        """
        Format a single group's section for streaming
        
        Returns ONLY the content for this specific group, not full response
        """
        location = multi_intent.location or context.destination or "khu v·ª±c n√†y"
        
        # Handle each group type separately with minimal formatting
        if group_name == "spots" and group_data.get("spots"):
            spots = group_data["spots"][:6]
            return self.response_aggregator._format_spots(spots, location)
        
        elif group_name == "hotels" and group_data.get("hotels"):
            hotels = group_data["hotels"][:5]
            return self.response_aggregator._format_hotels(hotels, location)
        
        elif group_name == "food" and group_data.get("food"):
            food = group_data["food"][:5]
            return self.response_aggregator._format_food(food, location)
        
        elif group_name == "itinerary" and group_data.get("itinerary"):
            # For itinerary, create just the section without full page
            duration = multi_intent.duration or context.duration or 3
            itinerary_section = self.response_aggregator._create_itinerary_section(
                group_data["itinerary"],
                duration
            )
            return {
                "reply": itinerary_section,
                "ui_type": "itinerary",
                "ui_data": {"itinerary": group_data["itinerary"]}
            }
        
        elif group_name == "cost" and group_data.get("costs"):
            cost_section = self.response_aggregator._create_cost_section(group_data["costs"])
            return {
                "reply": cost_section,
                "ui_type": "cost",
                "ui_data": {"costs": group_data["costs"]}
            }
        
        return None
    
    async def _handle_more_request(
        self,
        multi_intent,
        context,
        user_message: str
    ) -> Optional[Dict[str, Any]]:
        """
        Handle 'more' requests - when user wants more spots/hotels/food
        
        Directly executes fresh search without requiring new info gathering
        """
        intent = multi_intent.primary_intent
        location = multi_intent.location or getattr(context, 'destination', None)
        
        if not location:
            return None  # Need location to search
        
        logger.info(f"üîÑ Processing 'more' request: intent={intent}, location={location}")
        
        try:
            # Create fresh search task based on intent
            if intent == "find_spot":
                # Get spots from MongoDB
                spots = []
                if self.mongo_manager:
                    spots_col = self.mongo_manager.get_collection("spots_detailed")
                    if spots_col is not None:
                        # Find spots using address field (spots use address instead of province)
                        query = {"address": {"$regex": location, "$options": "i"}}
                        cursor = spots_col.find(query).skip(6).limit(6)  # Skip first 6, get next 6
                        for doc in cursor:
                            spots.append({
                                "name": doc.get("name", ""),
                                "province": location,  # Use location from context
                                "category": doc.get("category", ""),
                                "description": doc.get("description_short") or doc.get("description", ""),
                                "rating": doc.get("rating", 4.0),
                                "image": doc.get("image") or doc.get("image_url") or "",
                                "lat": doc.get("lat", 0),
                                "lng": doc.get("lng", 0)
                            })
                
                if spots:
                    return self.response_aggregator._format_spots(spots, location)
                else:
                    return {
                        "reply": f"üìç Hi·ªán t·∫°i t√¥i ƒë√£ hi·ªÉn th·ªã t·∫•t c·∫£ ƒë·ªãa ƒëi·ªÉm c√≥ trong d·ªØ li·ªáu v·ªÅ {location}.\n\n"
                                 f"B·∫°n c√≥ mu·ªën t√¨m kh√°ch s·∫°n ho·∫∑c xem l·ªãch tr√¨nh kh√¥ng?",
                        "ui_type": "options",
                        "ui_data": {
                            "options": [
                                f"üè® T√¨m kh√°ch s·∫°n {location}",
                                f"üóìÔ∏è L√™n l·ªãch tr√¨nh {location}"
                            ]
                        },
                        "context": context.to_dict(),
                        "status": "partial"
                    }
            
            elif intent == "find_hotel":
                hotels = []
                if self.mongo_manager:
                    hotels_col = self.mongo_manager.get_collection("hotels")
                    if hotels_col is not None:
                        query = {"province": {"$regex": location, "$options": "i"}}
                        cursor = hotels_col.find(query).skip(5).limit(5)
                        for doc in cursor:
                            hotels.append({
                                "name": doc.get("name", ""),
                                "province": doc.get("province", location),
                                "address": doc.get("address", ""),
                                "rating": doc.get("rating", 4.0),
                                "price": doc.get("price", 0),
                                "priceRange": doc.get("priceRange", f"{doc.get('price', 0):,} VNƒê/ƒë√™m"),
                                "image": doc.get("image_url") or doc.get("images", [""])[0] if doc.get("images") else "",
                                "amenities": doc.get("amenities", [])
                            })
                
                if hotels:
                    return self.response_aggregator._format_hotels(hotels, location)
                else:
                    return {
                        "reply": f"üè® ƒê√¢y l√† t·∫•t c·∫£ kh√°ch s·∫°n c√≥ trong d·ªØ li·ªáu v·ªÅ {location}.\n\n"
                                 f"B·∫°n c√≥ mu·ªën xem ƒë·ªãa ƒëi·ªÉm tham quan ho·∫∑c l√™n l·ªãch tr√¨nh kh√¥ng?",
                        "ui_type": "options",
                        "ui_data": {
                            "options": [
                                f"üìç ƒê·ªãa ƒëi·ªÉm tham quan {location}",
                                f"üóìÔ∏è L√™n l·ªãch tr√¨nh {location}"
                            ]
                        },
                        "context": context.to_dict(),
                        "status": "partial"
                    }
            
            elif intent == "find_food":
                food = []
                if self.mongo_manager:
                    food_col = self.mongo_manager.get_collection("food")
                    if food_col is not None:
                        query = {"province": {"$regex": location, "$options": "i"}}
                        cursor = food_col.find(query).skip(5).limit(5)
                        for doc in cursor:
                            food.append({
                                "name": doc.get("name", ""),
                                "province": doc.get("province", location),
                                "category": doc.get("category", ""),
                                "description": doc.get("description", ""),
                                "price": doc.get("price", ""),
                                "image": doc.get("image_url") or doc.get("images", [""])[0] if doc.get("images") else ""
                            })
                
                if food:
                    return self.response_aggregator._format_food(food, location)
                else:
                    return {
                        "reply": f"üçú ƒê√¢y l√† t·∫•t c·∫£ qu√°n ƒÉn c√≥ trong d·ªØ li·ªáu v·ªÅ {location}.",
                        "ui_type": "none",
                        "context": context.to_dict(),
                        "status": "partial"
                    }
        
        except Exception as e:
            logger.error(f"‚ùå Error handling more request: {e}")
            return None
        
        return None
    
    def _handle_special_intent_sync(
        self, 
        multi_intent, 
        context, 
        user_message: str
    ) -> Optional[Dict[str, Any]]:
        """
        Handle special intents synchronously for process_request()
        
        Handles: greeting, chitchat, thanks, farewell, book_hotel, calculate_cost, show_itinerary
        Returns response dict or None if normal processing should continue
        """
        intent = multi_intent.primary_intent
        
        # === HIGHEST PRIORITY: Check for show_itinerary intent FIRST ===
        # This must be checked BEFORE builder continuation logic
        if intent == "show_itinerary" or self._is_recall_itinerary_request(user_message):
            logger.info("üîç User wants to view existing itinerary (show_itinerary intent)")
            return self._handle_recall_itinerary(context)
        
        # === CHECK IF USER IS IN INTERACTIVE ITINERARY BUILDER MODE ===
        itinerary_builder = getattr(context, 'itinerary_builder', None)
        if itinerary_builder:
            # User is building itinerary interactively
            lower_msg = user_message.lower().strip()
            
            # FIX #3: Allow calculate_cost intent even in builder mode
            # User wants to see budget, NOT continue building
            if intent == "calculate_cost":
                logger.info("[FIX #3] üéØ calculate_cost request in builder mode - handling separately")
                return self._handle_cost_calculation_sync(multi_intent, context, user_message)
            
            # Check for cancel/reset commands
            cancel_patterns = ["h·ªßy", "huy", "cancel", "b·∫Øt ƒë·∫ßu l·∫°i", "bat dau lai", 
                             "l·∫≠p l·ªãch l·∫°i", "lap lich lai", "l√†m l·∫°i", "lam lai", "reset"]
            if any(p in lower_msg for p in cancel_patterns):
                context.itinerary_builder = None
                return {
                    "reply": "üîÑ ƒê√£ h·ªßy l·ªãch tr√¨nh hi·ªán t·∫°i.\n\n"
                             "B·∫°n c√≥ mu·ªën l·∫≠p l·ªãch tr√¨nh m·ªõi kh√¥ng? "
                             "H√£y cho t√¥i bi·∫øt b·∫°n mu·ªën ƒëi ƒë√¢u v√† bao nhi√™u ng√†y!",
                    "ui_type": "none",
                    "context": context.to_dict(),
                    "status": "partial"
                }
            
            # Continue building itinerary with user's input
            result = self._continue_interactive_itinerary_sync(user_message, context)
            if result:
                return result
        
        # === GREETING ===
        if intent == "greeting":
            return {
                "reply": "Xin ch√†o! üëã T√¥i l√† Saola - tr·ª£ l√Ω du l·ªãch AI c·ªßa b·∫°n. "
                         "T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n"
                         "‚Ä¢ üó∫Ô∏è L√™n l·ªãch tr√¨nh du l·ªãch\n"
                         "‚Ä¢ üè® T√¨m kh√°ch s·∫°n ph√π h·ª£p\n"
                         "‚Ä¢ üìç G·ª£i √Ω ƒë·ªãa ƒëi·ªÉm tham quan\n"
                         "‚Ä¢ üçú Kh√°m ph√° ·∫©m th·ª±c ƒë·ªãa ph∆∞∆°ng\n"
                         "‚Ä¢ üí∞ ∆Ø·ªõc t√≠nh chi ph√≠ chuy·∫øn ƒëi\n\n"
                         "B·∫°n mu·ªën ƒëi ƒë√¢u? üåç",
                "ui_type": "greeting",
                "context": context.to_dict(),
                "status": "partial"
            }
        
        # === CHITCHAT ===
        if intent == "chitchat":
            return {
                "reply": "T√¥i l√† Saola - tr·ª£ l√Ω du l·ªãch AI! ü¶å\n\n"
                         "T√¥i chuy√™n v·ªÅ du l·ªãch Vi·ªát Nam v√† c√≥ th·ªÉ gi√∫p b·∫°n:\n"
                         "‚Ä¢ L√™n k·∫ø ho·∫°ch chuy·∫øn ƒëi\n"
                         "‚Ä¢ T√¨m kh√°ch s·∫°n t·ªët nh·∫•t\n"
                         "‚Ä¢ G·ª£i √Ω ƒëi·ªÉm ƒë·∫øn h·∫•p d·∫´n\n\n"
                         "H√£y cho t√¥i bi·∫øt b·∫°n mu·ªën ƒëi ƒë√¢u nh√©! üó∫Ô∏è",
                "ui_type": "chitchat",
                "context": context.to_dict(),
                "status": "partial"
            }
        
        # === THANKS ===
        if intent == "thanks":
            return {
                "reply": "Kh√¥ng c√≥ g√¨ ·∫°! üòä R·∫•t vui ƒë∆∞·ª£c gi√∫p ƒë·ª° b·∫°n. "
                         "N·∫øu c·∫ßn h·ªó tr·ª£ th√™m v·ªÅ chuy·∫øn ƒëi, c·ª© h·ªèi t√¥i nh√©! ‚úàÔ∏è",
                "ui_type": "thanks",
                "context": context.to_dict(),
                "status": "partial"
            }
        
        # === FAREWELL ===
        if intent == "farewell":
            return {
                "reply": "T·∫°m bi·ªát b·∫°n! üëã Ch√∫c b·∫°n c√≥ chuy·∫øn ƒëi th·∫≠t vui v·∫ª! "
                         "H·∫πn g·∫∑p l·∫°i l·∫ßn sau! üåü",
                "ui_type": "farewell",
                "context": context.to_dict(),
                "status": "partial"
            }
        
        # === BOOK HOTEL ===
        if intent == "book_hotel":
            return self._handle_book_hotel_sync(multi_intent, context)
        
        # === COST CALCULATION ===
        if intent == "calculate_cost":
            return self._handle_cost_calculation_sync(multi_intent, context, user_message)
        
        # === GET LOCATION TIPS (tips/advice for selected spots) ===
        if intent == "get_location_tips":
            return self._handle_location_tips_sync(multi_intent, context, user_message)
        
        # === GET DETAIL (spot/hotel detail from context) ===
        if intent == "get_detail":

            return self._handle_detail_request_sync(multi_intent, context, user_message)
        
        # === SKIP special handling for planning/searching intents ===
        # These should go through PHASE 2 (plan & execute)
        skip_intents = ["plan_trip", "find_hotel", "find_food", "general_info", "find_spot"]
        if intent in skip_intents:
            # Check if this is actually a detail request (not a search)
            lower_msg = user_message.lower()
            detail_patterns = [
                "chi ti·∫øt v·ªÅ", "th√¥ng tin v·ªÅ", "cho t√¥i bi·∫øt v·ªÅ", "n√≥i v·ªÅ", "gi·ªõi thi·ªáu v·ªÅ",
                "chi tiet ve", "thong tin ve", "cho toi biet ve", "noi ve", "gioi thieu ve"
            ]
            is_detail_request = any(p in lower_msg for p in detail_patterns)
            
            if is_detail_request and intent == "find_spot":
                # This is actually a detail request, not a list search
                return self._handle_detail_request_sync(multi_intent, context, user_message)
            
            # === INTERACTIVE ITINERARY BUILDER ===
            # If user wants to plan a trip, start interactive mode instead of auto-generating
            if intent == "plan_trip":
                location = multi_intent.location
                duration = multi_intent.duration or getattr(context, 'num_days', None)
                
                if location and duration:
                    # Check if user wants interactive mode or already in building mode
                    itinerary_state = getattr(context, 'itinerary_builder', None)
                    
                    if itinerary_state is None:
                        # Start interactive itinerary builder
                        return self._start_interactive_itinerary_sync(location, duration, context)
                    else:
                        # Continue building itinerary
                        return self._continue_interactive_itinerary_sync(user_message, context)
            
            # Otherwise, let it go to PHASE 2 for normal processing
            return None
        
        # Check for ordinal reference in user_message (e.g., "ƒë·ªãa ƒëi·ªÉm ƒë·∫ßu ti√™n")
        ordinal_index = self._extract_ordinal_index(user_message.lower())
        if ordinal_index is not None:
            return self._handle_detail_request_sync(multi_intent, context, user_message)
        
        # === RECALL ITINERARY - "Xem l·∫°i l·ªãch tr√¨nh", "L·ªãch tr√¨nh c·ªßa t√¥i" ===
        if self._is_recall_itinerary_request(user_message):
            return self._handle_recall_itinerary(context)
        
        return None
    
    def _handle_book_hotel_sync(self, multi_intent, context) -> Optional[Dict[str, Any]]:
        """Handle book_hotel intent synchronously"""
        try:
            # Try to extract hotel name from keywords first
            hotel_name_from_keywords = multi_intent.keywords[0] if multi_intent.keywords else None
            location = getattr(context, 'destination', None)
            
            logger.info(f"üìç Book hotel request: hotel_name_from_keywords={hotel_name_from_keywords}, location={location}")
            
            # NEW: Use LLM to extract hotel name from user message for better accuracy
            user_message = getattr(multi_intent, 'original_message', '') or ''
            hotel_name = None
            hotel_url = None
            hotel_price = None
            
            # Check if we have last_hotels in context
            last_hotels = getattr(context, 'last_hotels', [])
            
            if last_hotels and user_message:
                # Use LLM to match user intent with hotel list
                logger.info(f"ü§ñ [HOTEL FIX] Using LLM to extract hotel from: '{user_message}'")
                
                hotel_list_text = "\n".join([
                    f"{i+1}. {h.get('name')} - {h.get('price', 0):,} VNƒê/ƒë√™m"
                    for i, h in enumerate(last_hotels[:10])
                ])
                
                llm_prompt = f"""USER n√≥i: "{user_message}"

DANH S√ÅCH KH√ÅCH S·∫†N:
{hotel_list_text}

USER mu·ªën ch·ªçn kh√°ch s·∫°n n√†o? 
- N·∫øu r√µ r√†ng ‚Üí tr·∫£ v·ªÅ S·ªê TH·ª® T·ª∞ (1-{len(last_hotels)})
- N·∫øu kh√¥ng r√µ ‚Üí tr·∫£ v·ªÅ "none"

CH·ªà TR·∫¢ V·ªÄ S·ªê ho·∫∑c "none", KH√îNG GI·∫¢I TH√çCH."""

                try:
                    llm_result = self.llm.complete(
                        prompt=llm_prompt,
                        max_tokens=10,
                        temperature=0.1
                    ).strip().lower()
                    
                    logger.info(f"ü§ñ [HOTEL FIX] LLM result: {llm_result}")
                    
                    # Parse index
                    import re
                    match = re.search(r'\d+', llm_result)
                    if match:
                        hotel_index = int(match.group()) - 1  # Convert to 0-based
                        if 0 <= hotel_index < len(last_hotels):
                            selected_hotel_data = last_hotels[hotel_index]
                            hotel_name = selected_hotel_data.get('name')
                            hotel_price = selected_hotel_data.get('price')
                            hotel_url = selected_hotel_data.get('url')
                            logger.info(f"‚úÖ [HOTEL FIX] LLM selected hotel #{hotel_index + 1}: {hotel_name}")
                except Exception as llm_error:
                    logger.error(f"‚ùå [HOTEL FIX] LLM extraction failed: {llm_error}")
            
            # Fallback to keyword-based extraction
            if not hotel_name and hotel_name_from_keywords:
                hotel_name = hotel_name_from_keywords
                logger.info(f"‚ö†Ô∏è [HOTEL FIX] Using fallback keyword extraction: {hotel_name}")
                
                # Try to find hotel price from context.last_hotels with fuzzy matching
                if last_hotels:
                    # Use fuzzy matching
                    from difflib import SequenceMatcher
                    best_match = None
                    best_ratio = 0.0
                    
                    for hotel in last_hotels:
                        hotel_name_in_list = hotel.get("name", "")
                        ratio = SequenceMatcher(None, 
                                               hotel_name.lower(), 
                                               hotel_name_in_list.lower()).ratio()
                        
                        if ratio > best_ratio:
                            best_ratio = ratio
                            best_match = hotel
                    
                    if best_match and best_ratio > 0.6:  # 60% similarity threshold
                        hotel_name = best_match.get("name")  # Use full hotel name
                        hotel_price = best_match.get("price")
                        hotel_url = best_match.get("url")
                        logger.info(f"‚úÖ [HOTEL FIX] Fuzzy match found (ratio={best_ratio:.2f}): {hotel_name}, price: {hotel_price}")
            
            if hotel_name:
                # Store selected hotel in context
                context.selected_hotel = hotel_name
                
                # If not found in context, search database
                if not hotel_price and self.mongo_manager:
                    hotels_col = self.mongo_manager.get_collection("hotels")
                    if hotels_col is not None:
                        first_word = hotel_name.split()[0] if hotel_name.split() else hotel_name
                        hotel_doc = hotels_col.find_one({
                            "name": {"$regex": first_word, "$options": "i"}
                        })
                        if hotel_doc:
                            hotel_url = hotel_doc.get("url")
                            hotel_price = hotel_doc.get("price")
                            logger.info(f"‚úÖ Found hotel in DB: {hotel_doc.get('name')}")
                
                # Save price to context
                if hotel_price:
                    context.selected_hotel_price = hotel_price
                    logger.info(f"üí∞ Saved selected_hotel_price to context: {hotel_price:,} VNƒê")
                
                # Build booking response
                booking_links = []
                if hotel_url:
                    booking_links.append(f"üîó [ƒê·∫∑t ph√≤ng t·∫°i website g·ªëc]({hotel_url})")
                
                search_name = hotel_name.replace(" ", "+")
                booking_links.extend([
                    f"üîó [T√¨m tr√™n Booking.com](https://www.booking.com/searchresults.html?ss={search_name})",
                    f"üîó [T√¨m tr√™n Agoda](https://www.agoda.com/search?q={search_name})",
                    f"üîó [T√¨m tr√™n Traveloka](https://www.traveloka.com/vi-vn/hotel/search?q={search_name})"
                ])
                
                price_info = f"\nüí∞ Gi√° tham kh·∫£o: **{hotel_price:,} VNƒê/ƒë√™m**" if hotel_price else ""
                
                return {
                    "reply": f"üè® **ƒê·∫∑t ph√≤ng: {hotel_name}**{price_info}\n\n"
                             f"üì± **C√°ch ƒë·∫∑t ph√≤ng:**\n"
                             f"{chr(10).join(booking_links)}\n\n"
                             f"üí° **L∆∞u √Ω khi ƒë·∫∑t ph√≤ng:**\n"
                             f"‚Ä¢ So s√°nh gi√° gi·ªØa c√°c trang ƒë·ªÉ t√¨m ∆∞u ƒë√£i t·ªët nh·∫•t\n"
                             f"‚Ä¢ Ki·ªÉm tra ch√≠nh s√°ch h·ªßy ph√≤ng tr∆∞·ªõc khi ƒë·∫∑t\n"
                             f"‚Ä¢ ƒê·ªçc review g·∫ßn ƒë√¢y t·ª´ kh√°ch h√†ng\n\n"
                             f"B·∫°n c·∫ßn t√¥i ∆∞·ªõc t√≠nh chi ph√≠ to√†n b·ªô chuy·∫øn ƒëi kh√¥ng? üí∞",
                    "ui_type": "booking",
                    "ui_data": {
                        "selected_hotel": hotel_name,
                        "hotel_url": hotel_url,
                        "hotel_price": hotel_price,
                        "booking_links": booking_links
                    },
                    "status": "partial",
                    "context": context.to_dict()
                }
            else:
                return {
                    "reply": "B·∫°n mu·ªën ƒë·∫∑t ph√≤ng kh√°ch s·∫°n n√†o? üè®\n"
                             "H√£y cho t√¥i bi·∫øt t√™n kh√°ch s·∫°n b·∫°n quan t√¢m!",
                    "ui_type": "booking_prompt",
                    "context": context.to_dict(),
                    "status": "partial"
                }
        except Exception as e:
            logger.error(f"‚ùå Book hotel error: {e}")
            import traceback
            traceback.print_exc()
            return {
                "reply": f"üè® T√¥i ghi nh·∫≠n b·∫°n mu·ªën ƒë·∫∑t ph√≤ng.\n\n"
                         f"B·∫°n c√≥ th·ªÉ t√¨m ki·∫øm kh√°ch s·∫°n tr√™n:\n"
                         f"‚Ä¢ [Booking.com](https://www.booking.com)\n"
                         f"‚Ä¢ [Agoda](https://www.agoda.com)\n"
                         f"‚Ä¢ [Traveloka](https://www.traveloka.com)\n\n"
                         f"Ho·∫∑c cho t√¥i bi·∫øt t√™n kh√°ch s·∫°n c·ª• th·ªÉ b·∫°n mu·ªën ƒë·∫∑t!",
                "ui_type": "booking",
                "context": context.to_dict(),
                "status": "partial"
            }
    
    # ==================== INTERACTIVE ITINERARY BUILDER ====================
    
    def _start_interactive_itinerary_sync(self, location: str, duration: int, context) -> Dict[str, Any]:
        """Start interactive itinerary building mode - ask user for Day 1 preferences"""
        try:
            logger.info(f"üóìÔ∏è Starting interactive itinerary builder: {location}, {duration} days")
            
            # Get available spots for this location
            spots = self._get_spots_for_location_sync(location)
            
            if not spots:
                # Fallback to auto-generate if no spots found
                logger.info("‚ö†Ô∏è No spots found for interactive mode, falling back to auto-generate")
                return None  # Let it proceed to PHASE 2
            
            # Initialize itinerary builder state in context
            context.itinerary_builder = {
                "location": location,
                "total_days": duration,
                "current_day": 1,
                "days_plan": {},  # {1: [spot1, spot2], 2: [...], ...}
                "available_spots": [
                    {
                        "id": i+1, 
                        "name": s.get("name"), 
                        "category": s.get("category") or s.get("tags", [None])[0] if s.get("tags") else "Tham quan",
                        "rating": s.get("rating"),
                        "description": s.get("description", ""),
                        "image": s.get("image") or s.get("image_url") or (s.get("images", [None])[0] if s.get("images") else None),
                        "image_url": s.get("image_url") or s.get("image") or (s.get("images", [None])[0] if s.get("images") else None)
                    }
                    for i, s in enumerate(spots[:20])  # Limit to 20 spots
                ]
            }
            context.destination = location
            context.num_days = duration
            
            # Format spots list for display
            def get_category(s):
                cat = s.get('category')
                if cat:
                    return cat
                tags = s.get('tags', [])
                if tags and tags[0]:
                    return tags[0]
                return "ƒê·ªãa ƒëi·ªÉm tham quan"
            
            spots_list = "\n".join([
                f"  {i+1}. **{s.get('name')}**"
                for i, s in enumerate(spots[:15])
            ])
            
            reply = f"""üóìÔ∏è **L·∫≠p l·ªãch tr√¨nh {duration} ng√†y t·∫°i {location}**

T√¥i s·∫Ω gi√∫p b·∫°n l√™n k·∫ø ho·∫°ch chi ti·∫øt cho t·ª´ng ng√†y!

üìç **NG√ÄY 1** - B·∫°n mu·ªën ƒëi nh·ªØng ƒë·ªãa ƒëi·ªÉm n√†o?

D∆∞·ªõi ƒë√¢y l√† c√°c ƒë·ªãa ƒëi·ªÉm ph·ªï bi·∫øn t·∫°i {location}:
{spots_list}

üí° **H∆∞·ªõng d·∫´n:**
‚Ä¢ Nh·∫≠p s·ªë th·ª© t·ª± ƒë·ªãa ƒëi·ªÉm (VD: "1, 3, 5" ho·∫∑c "1 3 5")
‚Ä¢ Ho·∫∑c g√µ t√™n ƒë·ªãa ƒëi·ªÉm b·∫°n mu·ªën ƒëi
‚Ä¢ G√µ **"b·ªè qua"** n·∫øu mu·ªën t√¥i t·ª± ƒë·ªông l√™n l·ªãch cho ng√†y n√†y
‚Ä¢ G√µ **"t·ª± ƒë·ªông"** ƒë·ªÉ t√¥i t·ª± t·∫°o to√†n b·ªô l·ªãch tr√¨nh"""

            # CRITICAL: Store selected spot IDs to avoid duplication in later days
            context.selected_spot_ids = []  # Initialize empty list for tracking

            # Format spots for UI with idx
            spots_for_ui = [
                {
                    "idx": i + 1,
                    "id": s.get("_id") or s.get("id") or f"spot_{i+1}",
                    "name": s.get("name"),
                    "rating": s.get("rating"),
                    "description": s.get("description", "")[:100] if s.get("description") else "",
                    "image": s.get("image") or s.get("image_url") or (s.get("images", [None])[0] if s.get("images") else None)
                }
                for i, s in enumerate(spots[:15])
            ]
            
            return {
                "reply": reply,
                "ui_type": "itinerary_builder",
                "ui_data": {
                    "spots": spots_for_ui,
                    "current_day": 1,
                    "total_days": duration,
                    "destination": location
                },
                "context": context.to_dict(),
                "status": "partial"
            }
            
        except Exception as e:
            logger.error(f"‚ùå Start interactive itinerary error: {e}")
            import traceback
            traceback.print_exc()
            return None  # Fallback to auto-generate
    
    def _rebuild_builder_from_last(self, last_itinerary: Dict, context) -> Dict:
        """
        Kh√¥i ph·ª•c itinerary_builder t·ª´ last_itinerary ƒë√£ ch·ªët.
        D√πng khi user mu·ªën BACKTRACK (quay l·∫°i s·ª≠a l·ªãch tr√¨nh).
        
        Args:
            last_itinerary: L·ªãch tr√¨nh ƒë√£ finalize tr∆∞·ªõc ƒë√≥
            context: Enhanced context ƒë·ªÉ l·∫•y th√¥ng tin b·ªï sung
            
        Returns:
            Dict builder state c√≥ th·ªÉ d√πng ti·∫øp
        """
        if not last_itinerary:
            return None
        
        # Extract data from last_itinerary
        location = last_itinerary.get("location") or getattr(context, 'destination', '')
        duration = last_itinerary.get("duration") or getattr(context, 'duration', 3)
        days_data = last_itinerary.get("days", [])
        
        # Rebuild days_plan t·ª´ itinerary days
        days_plan = {}
        for day_info in days_data:
            day_num = day_info.get("day", 1)
            spots = day_info.get("spots", [])
            # Convert spots to proper format
            days_plan[str(day_num)] = [
                {"name": s} if isinstance(s, str) else s 
                for s in spots
            ]
        
        builder = {
            "location": location,
            "total_days": duration,
            "current_day": 1,  # Reset v·ªÅ ng√†y 1 ƒë·ªÉ user ch·ªçn th√™m
            "days_plan": days_plan,
            "available_spots": [],  # S·∫Ω ƒë∆∞·ª£c fill l·∫°i khi show options
            "is_rebuilt": True  # Flag ƒë·ªÉ bi·∫øt ƒë√¢y l√† builder ƒë∆∞·ª£c kh√¥i ph·ª•c
        }
        
        total_spots = sum(len(spots) for spots in days_plan.values())
        logger.info(f"üîÑ Rebuilt builder from last_itinerary: {location}, {duration} days, {total_spots} spots preserved")
        
        return builder

    def _continue_interactive_itinerary_sync(self, user_message: str, context) -> Optional[Dict[str, Any]]:
        """Continue building itinerary based on user's selection with BACKTRACKING support"""
        try:
            builder = getattr(context, 'itinerary_builder', None)
            if not builder:
                return None
            
            current_day = builder.get("current_day", 1)
            total_days = builder.get("total_days", 3)
            location = builder.get("location", "")
            available_spots = builder.get("available_spots", [])
            days_plan = builder.get("days_plan", {})
            
            lower_msg = user_message.lower().strip()
            
            # üîÑ BACKTRACKING DETECTION (PRIORITY #1)
            # Check if user wants to go back to previous step while in CHOOSING_HOTEL state
            workflow_state = getattr(context, 'workflow_state', 'INITIAL')
            
            backtrack_to_spots_keywords = [
                "th√™m ƒë·ªãa ƒëi·ªÉm", "them dia diem", "th√™m spot", "them spot",
                "th√™m ƒëi·ªÉm", "them diem", "c√≤n thi·∫øu", "con thieu",
                "th√™m n·ªØa", "them nua", "th√™m m·ªôt ƒëi·ªÉm", "them mot diem",
                "th√™m check-in", "them check-in", "th√™m check in"
            ]
            
            if workflow_state == "CHOOSING_HOTEL" and any(kw in lower_msg for kw in backtrack_to_spots_keywords):
                logger.info(f"üîÑ BACKTRACK detected: User wants to add more spots while at CHOOSING_HOTEL")
                
                # Count current spots
                total_spots = sum(len(spots) for spots in days_plan.values())
                
                # Transition back to CHOOSING_SPOTS
                context.workflow_state = "CHOOSING_SPOTS"
                builder["current_day"] = 1  # Reset to day 1 for adding
                context.itinerary_builder = builder
                
                return {
                    "reply": f"""üîÑ **ƒê∆∞·ª£c! Quay l·∫°i b·ªï sung ƒë·ªãa ƒëi·ªÉm**
                    
‚úÖ **T√¥i ƒë√£ gi·ªØ nguy√™n:**
‚Ä¢ {total_spots} ƒë·ªãa ƒëi·ªÉm ƒë√£ ch·ªçn cho {len(days_plan)} ng√†y

üìç **Gi·ªù b·∫°n mu·ªën th√™m ƒë·ªãa ƒëi·ªÉm cho ng√†y n√†o?**

G√µ s·ªë ng√†y (v√≠ d·ª•: "Ng√†y 1" ho·∫∑c "1") ƒë·ªÉ t√¥i hi·ªÉn th·ªã th√™m g·ª£i √Ω cho ng√†y ƒë√≥.
Ho·∫∑c g√µ **"xong"** n·∫øu kh√¥ng mu·ªën th√™m n·ªØa.""",
                    "ui_type": "none",
                    "context": context.to_dict(),
                    "status": "backtrack_to_spots"
                }
            
            # Check for auto-generate commands
            if lower_msg in ["t·ª± ƒë·ªông", "tu dong", "auto", "t·ª± ƒë·ªông t·∫°o", "tu dong tao"]:
                # Clear builder state and let auto-generate
                context.itinerary_builder = None
                logger.info("ü§ñ User requested auto-generate itinerary")
                return None  # Proceed to PHASE 2 for auto-generation
            
            # Check for skip current day
            if lower_msg in ["b·ªè qua", "bo qua", "skip", "ti·∫øp", "tiep"]:
                # Skip this day (empty or auto-fill later)
                days_plan[str(current_day)] = []
                logger.info(f"‚è≠Ô∏è Skipping Day {current_day}")
                advance_day = True
            # Check for "done" / "xong" / "ti·∫øp t·ª•c" to advance to next day
            # Support both exact match and contains check for more flexible input
            elif (lower_msg in ["xong", "done", "ti·∫øp t·ª•c", "tiep tuc", "ok", "ƒë∆∞·ª£c", "duoc", "next"] or
                  any(keyword in lower_msg for keyword in ["xong", "done", "ch·ªët", "chot", "finalize", "ho√†n th√†nh", "hoan thanh", "k·∫øt th√∫c", "ket thuc"])):
                # User confirms current selection, move to next day
                logger.info(f"‚úÖ User confirmed Day {current_day}, advancing...")
                advance_day = True
            else:
                # Parse user's selection and ADD to current day (not replace)
                selected_spots = self._parse_spot_selection(user_message, available_spots)
                
                # Get existing spots for current day and merge
                existing_spots = days_plan.get(str(current_day), [])
                existing_ids = {s.get("id") for s in existing_spots}
                
                # CRITICAL: Track all selected spot IDs globally to prevent duplication
                if not hasattr(context, 'selected_spot_ids'):
                    context.selected_spot_ids = []
                
                # Add new spots that aren't already selected
                for spot in selected_spots:
                    spot_id = spot.get("id")
                    if spot_id not in existing_ids:
                        existing_spots.append(spot)
                        existing_ids.add(spot_id)
                        # Add to global tracking list
                        if spot_id not in context.selected_spot_ids:
                            context.selected_spot_ids.append(spot_id)
                            logger.info(f"  üîí Locked spot ID: {spot_id} ({spot.get('name')})")
                
                days_plan[str(current_day)] = existing_spots
                logger.info(f"‚úÖ Day {current_day} spots (merged): {[s.get('name') for s in existing_spots]}")
                logger.info(f"üìä Total selected spot IDs: {len(context.selected_spot_ids)}")
                
                # Don't advance day yet - wait for user to say "xong" or "ti·∫øp t·ª•c"
                # But if this is a multi-selection (e.g., "1, 5, 9"), advance
                advance_day = len(selected_spots) >= 2 or "," in user_message or " " in user_message.strip()
            
            # Update context
            builder["days_plan"] = days_plan
            
            if advance_day:
                builder["current_day"] = current_day + 1
                context.itinerary_builder = builder
                
                # Check if we're done with all days
                if current_day >= total_days:
                    # CRITICAL: Update workflow state BEFORE finalize
                    context.workflow_state = "CHOOSING_HOTEL"
                    logger.info(f"üîÑ State transition: CHOOSING_SPOTS ‚Üí CHOOSING_HOTEL")
                    
                    # Finalize itinerary selection and prompt hotel selection
                    return self._finalize_interactive_itinerary_sync(context)
                
                # Ask for next day
                next_day = current_day + 1
                
                # Show what was selected for current day
                selected_names = [s.get("name") for s in days_plan.get(str(current_day), [])]
                selected_text = ", ".join(selected_names) if selected_names else "T·ª± ƒë·ªông l√™n l·ªãch"
                
                # CRITICAL: Filter out already selected spots from available spots
                # Use global tracking list to ensure no spot appears twice
                selected_ids = set(context.selected_spot_ids) if hasattr(context, 'selected_spot_ids') else set()
                
                remaining_spots = [
                    s for s in available_spots 
                    if s.get("id") not in selected_ids
                ]
                
                logger.info(f"üîç Filtering: {len(available_spots)} total ‚Üí {len(remaining_spots)} remaining (excluded {len(selected_ids)} selected)")
                
                spots_list = "\n".join([
                    f"  {s.get('id')}. **{s.get('name')}** ({s.get('category', 'Tham quan')})"
                    for s in remaining_spots[:12]
                ])
                
                reply = f"""‚úÖ **Ng√†y {current_day}:** {selected_text}

üìç **NG√ÄY {next_day}** - B·∫°n mu·ªën ƒëi nh·ªØng ƒë·ªãa ƒëi·ªÉm n√†o?

{spots_list if spots_list else "T·∫•t c·∫£ ƒë·ªãa ƒëi·ªÉm ƒë√£ ƒë∆∞·ª£c ch·ªçn!"}

üí° Nh·∫≠p s·ªë th·ª© t·ª± ho·∫∑c t√™n ƒë·ªãa ƒëi·ªÉm (VD: "2, 4, 6")
   G√µ **"b·ªè qua"** ƒë·ªÉ t√¥i t·ª± ƒë·ªông l√™n l·ªãch cho ng√†y n√†y"""

                # Format remaining spots for UI
                spots_for_ui = [
                    {
                        "idx": s.get("id"),
                        "id": f"spot_{s.get('id')}",
                        "name": s.get("name"),
                        "category": s.get("category", "Tham quan"),
                        "rating": s.get("rating"),
                        "description": s.get("description", "")[:100] if s.get("description") else "",
                        "image": s.get("image") or s.get("image_url") or (s.get("images", [None])[0] if s.get("images") else None)
                    }
                    for s in remaining_spots[:12]
                ]
                
            else:
                # User added single spot, ask if they want to add more or continue
                context.itinerary_builder = builder
                
                selected_names = [s.get("name") for s in days_plan.get(str(current_day), [])]
                selected_text = ", ".join(selected_names)
                
                # CRITICAL: Show remaining spots (filter out already selected)
                selected_ids = set(context.selected_spot_ids) if hasattr(context, 'selected_spot_ids') else set()
                remaining_spots = [
                    s for s in available_spots 
                    if s.get("id") not in selected_ids
                ]
                
                reply = f"""‚úÖ ƒê√£ th√™m v√†o **Ng√†y {current_day}**: {selected_text}

üí° B·∫°n c√≥ th·ªÉ:
‚Ä¢ Nh·∫≠p th√™m s·ªë ƒë·ªÉ th√™m ƒë·ªãa ƒëi·ªÉm
‚Ä¢ G√µ **"xong"** ho·∫∑c **"ti·∫øp t·ª•c"** ƒë·ªÉ chuy·ªÉn sang ng√†y ti·∫øp theo
‚Ä¢ G√µ **"b·ªè qua"** ƒë·ªÉ b·ªè qua ng√†y n√†y"""

                spots_for_ui = [
                    {
                        "idx": s.get("id"),
                        "id": f"spot_{s.get('id')}",
                        "name": s.get("name"),
                        "category": s.get("category", "Tham quan"),
                        "rating": s.get("rating"),
                        "description": s.get("description", "")[:100] if s.get("description") else "",
                        "image": s.get("image") or s.get("image_url") or (s.get("images", [None])[0] if s.get("images") else None)
                    }
                    for s in remaining_spots[:12]
                ]
                next_day = current_day  # Still on same day
            
            return {
                "reply": reply,
                "ui_type": "itinerary_builder",
                "ui_data": {
                    "spots": spots_for_ui,
                    "current_day": next_day,
                    "total_days": total_days,
                    "destination": location
                },
                "context": context.to_dict(),
                "status": "partial"
            }
            
        except Exception as e:
            logger.error(f"‚ùå Continue interactive itinerary error: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    def _parse_spot_selection(self, user_message: str, available_spots: list) -> list:
        """Parse user's spot selection from message"""
        import re
        selected = []
        
        # Try to extract numbers
        numbers = re.findall(r'\d+', user_message)
        if numbers:
            for num_str in numbers:
                num = int(num_str)
                for spot in available_spots:
                    if spot.get("id") == num:
                        selected.append(spot)
                        break
        
        # Also try to match by name
        lower_msg = user_message.lower()
        for spot in available_spots:
            spot_name = spot.get("name", "").lower()
            # Check if any significant word from spot name is in message
            words = [w for w in spot_name.split() if len(w) > 2]
            if any(word in lower_msg for word in words):
                if spot not in selected:
                    selected.append(spot)
        
        return selected
    
    def _finalize_interactive_itinerary_sync(self, context) -> Dict[str, Any]:
        """Finalize the interactive itinerary and generate final response"""
        try:
            builder = context.itinerary_builder
            location = builder.get("location", "")
            total_days = builder.get("total_days", 3)
            days_plan = builder.get("days_plan", {})
            
            logger.info(f"üìã Finalizing itinerary: {total_days} days at {location}")
            logger.info(f"üîç DEBUG: days_plan keys = {list(days_plan.keys())}")
            
            # Build itinerary text
            itinerary_parts = []
            all_spots = []
            spots_details = []  # Store full spot details for frontend
            
            for day_num in range(1, total_days + 1):
                day_spots = days_plan.get(str(day_num), [])
                
                if day_spots:
                    spots_text = "\n".join([
                        f"    ‚Ä¢ {self._get_time_slot(i)} - {s.get('name')}"
                        for i, s in enumerate(day_spots)
                    ])
                    all_spots.extend(day_spots)
                    # Collect spot details with descriptions
                    for spot in day_spots:
                        spots_details.append({
                            "name": spot.get("name", ""),
                            "description": spot.get("description", "ƒê·ªãa ƒëi·ªÉm du l·ªãch n·ªïi ti·∫øng"),
                            "address": spot.get("address", ""),
                            "price_range": spot.get("price_range", "Mi·ªÖn ph√≠"),
                            "image_url": spot.get("image_url", ""),
                            "source_url": spot.get("url", ""),  # Link to original article
                            "tips": spot.get("tips", ""),
                            # Remove rating, add images array
                            "images": spot.get("images", [])
                        })
                else:
                    # Auto-fill with suggestions
                    spots_text = "    ‚Ä¢ T·ª± do kh√°m ph√° ho·∫∑c ngh·ªâ ng∆°i"
                
                itinerary_parts.append(f"üìÖ **Ng√†y {day_num}:**\n{spots_text}")
            
            itinerary_text = "\n\n".join(itinerary_parts)
            
            # PROACTIVE: Suggest next actions with STATE-AWARE message
            # Since we just finished CHOOSING_SPOTS, next step is CHOOSING_HOTEL
            reply = f"""üóìÔ∏è **L·ªäCH TR√åNH {total_days} NG√ÄY T·∫†I {location.upper()}**

{itinerary_text}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚úÖ **Tuy·ªát v·ªùi! B·∫°n ƒë√£ ch·ªçn xong ƒë·ªãa ƒëi·ªÉm cho {total_days} ng√†y.**

üéØ **B∆Ø·ªöC TI·∫æP THEO: Ch·ªçn kh√°ch s·∫°n**

‚ö†Ô∏è **L∆∞u √Ω quan tr·ªçng:**
‚Ä¢ B·∫°n c·∫ßn ch·ªçn kh√°ch s·∫°n tr∆∞·ªõc khi t√≠nh t·ªïng chi ph√≠
‚Ä¢ T√¥i s·∫Ω g·ª£i √Ω c√°c kh√°ch s·∫°n ph√π h·ª£p v·ªõi ng√¢n s√°ch c·ªßa b·∫°n

üí° **B·∫°n mu·ªën l√†m g√¨ ti·∫øp theo?**

üè® **1. T√¨m kh√°ch s·∫°n (∆ØU TI√äN)** - G√µ: "t√¨m kh√°ch s·∫°n" ho·∫∑c "hotel"
ÔøΩ **2. Xem l∆∞u √Ω ƒë·ªãa ƒëi·ªÉm** - G√µ: "c√≥ l∆∞u √Ω g√¨ kh√¥ng"
üìç **3. Xem chi ti·∫øt ƒë·ªãa ƒëi·ªÉm** - G√µ: "chi ti·∫øt v·ªÅ [t√™n ƒë·ªãa ƒëi·ªÉm]"
ÔøΩ **4. L·∫≠p l·∫°i** - G√µ: "l·∫≠p l·ªãch l·∫°i"

‚è∏Ô∏è **Mu·ªën t√≠nh chi ph√≠?** H√£y ch·ªçn kh√°ch s·∫°n tr∆∞·ªõc nh√©!

üí¨ H√£y n√≥i cho t√¥i bi·∫øt b·∫°n mu·ªën l√†m g√¨ ti·∫øp theo?"""

            # Create itinerary data for UI with next_actions
            itinerary_items = [
                {
                    "day": day_num,
                    "title": f"Kh√°m ph√° {location}" if days_plan.get(str(day_num)) else "T·ª± do kh√°m ph√°",
                    "morning": days_plan.get(str(day_num), [{}])[0].get("name") if days_plan.get(str(day_num)) and len(days_plan.get(str(day_num), [])) > 0 else "T·ª± do",
                    "afternoon": days_plan.get(str(day_num), [{}])[1].get("name") if days_plan.get(str(day_num)) and len(days_plan.get(str(day_num), [])) > 1 else (days_plan.get(str(day_num), [{}])[0].get("name") if days_plan.get(str(day_num)) and len(days_plan.get(str(day_num), [])) == 1 else "T·ª± do"),
                    "evening": days_plan.get(str(day_num), [{}])[2].get("name") if days_plan.get(str(day_num)) and len(days_plan.get(str(day_num), [])) > 2 else "Ngh·ªâ ng∆°i"
                }
                for day_num in range(1, total_days + 1)
            ]
            
            # Clear builder state
            context.itinerary_builder = None
            context.last_itinerary = {
                "location": location,
                "duration": total_days,
                "days": [
                    {
                        "day": day_num,
                        "spots": [s.get("name") for s in days_plan.get(str(day_num), [])]
                    }
                    for day_num in range(1, total_days + 1)
                ]
            }
            
            logger.info(f"‚úÖ DEBUG: Finalize completed successfully")
            logger.info(f"üìä DEBUG: Reply length = {len(reply)} chars, ui_type = 'itinerary'")
            
            return {
                "reply": reply,
                "ui_type": "itinerary",
                "ui_data": {
                    "items": itinerary_items,
                    "destination": location,
                    "days": total_days,
                    "total_days": total_days,
                    "spots_details": spots_details,  # NEW: Full spot details for frontend
                    # CRITICAL: Prioritize hotel selection
                    "actions": [
                        {"label": "üè® T√¨m kh√°ch s·∫°n (∆Øu ti√™n)", "action": "t√¨m kh√°ch s·∫°n"},
                        {"label": "ÔøΩ Xem l∆∞u √Ω", "action": "c√≥ l∆∞u √Ω g√¨ kh√¥ng"},
                        {"label": "ÔøΩ L·∫≠p l·∫°i", "action": "l·∫≠p l·ªãch l·∫°i"}
                    ],
                    "workflow_state": "CHOOSING_HOTEL",
                    "next_step_hint": "Ch·ªçn kh√°ch s·∫°n tr∆∞·ªõc khi t√≠nh chi ph√≠"
                },
                "context": context.to_dict(),
                "status": "success"
            }
            
        except Exception as e:
            logger.error(f"‚ùå Finalize itinerary error: {e}")
            import traceback
            traceback.print_exc()
            context.itinerary_builder = None
            return None
    
    def _get_time_slot(self, index: int) -> str:
        """Get time slot based on activity index"""
        time_slots = [
            "08:00", "09:30", "11:00", "12:30", 
            "14:00", "15:30", "17:00", "19:00"
        ]
        return time_slots[index % len(time_slots)]
    
    def _get_spots_for_location_sync(self, location: str) -> list:
        """Get spots for a location from database"""
        if not self.mongo_manager:
            return []
        
        try:
            from unidecode import unidecode
            province_id = unidecode(location.lower()).replace(" ", "-")
        except ImportError:
            province_id = location.lower().replace(" ", "-")
        
        spots_col = self.mongo_manager.get_collection("spots_detailed")
        if spots_col is None:
            return []
        
        spots = list(spots_col.find({"province_id": province_id}).limit(20))
        return [_clean_mongo_doc(s) for s in spots]
    
    # ==================== END INTERACTIVE ITINERARY BUILDER ====================

    def _handle_cost_calculation_sync(self, multi_intent, context, user_message: str) -> Optional[Dict[str, Any]]:
        """Handle cost calculation synchronously with STATE VALIDATION"""
        try:
            location = getattr(context, 'destination', None) or multi_intent.location
            duration = getattr(context, 'duration', None) or multi_intent.duration
            
            # Try to extract from message if not in context
            if not location or not duration:
                extracted = self._extract_location_and_duration_from_query(user_message)
                if extracted:
                    extracted_location, extracted_duration = extracted
                    location = location or extracted_location
                    duration = duration or extracted_duration
            
            if not location:
                return {
                    "reply": "B·∫°n mu·ªën t√≠nh chi ph√≠ cho chuy·∫øn ƒëi ƒë·∫øn ƒë√¢u? üó∫Ô∏è\n"
                             "H√£y cho t√¥i bi·∫øt ƒëi·ªÉm ƒë·∫øn c·ªßa b·∫°n!",
                    "ui_type": "options",
                    "context": context.to_dict(),
                    "status": "need_info"
                }
            
            if not duration:
                return {
                    "reply": f"B·∫°n d·ª± ƒë·ªãnh ƒëi {location} trong bao nhi√™u ng√†y? üìÖ",
                    "ui_type": "options",
                    "ui_data": {"options": ["2 ng√†y", "3 ng√†y", "5 ng√†y", "7 ng√†y"]},
                    "context": context.to_dict(),
                    "status": "need_info"
                }
            
            # FIX 3: Auto-select hotel with LLM reasoning instead of blocking user
            workflow_state = getattr(context, 'workflow_state', 'INITIAL')
            selected_hotel = getattr(context, 'selected_hotel', None)
            last_hotels = getattr(context, 'last_hotels', [])
            
            # If user hasn't selected hotel, use LLM to auto-select based on budget
            if not selected_hotel and last_hotels:
                logger.info(f"ü§ñ [FIX 3] Auto-selecting hotel with LLM reasoning")
                
                try:
                    # Extract budget preference from user message or context
                    budget = getattr(context, 'budget', None)
                    people_count = getattr(context, 'people_count', 1)
                    
                    # Build hotel list for LLM
                    hotel_list = []
                    for i, hotel in enumerate(last_hotels[:5], 1):
                        name = hotel.get('name', 'N/A')
                        price = hotel.get('price', 0)
                        hotel_list.append(f"{i}. {name} - {price:,} VNƒê/ƒë√™m")
                    
                    # LLM prompt for auto-selection
                    prompt = f"""B·∫°n l√† chuy√™n gia t∆∞ v·∫•n du l·ªãch.

USER mu·ªën t√≠nh chi ph√≠ cho chuy·∫øn ƒëi {location} ({duration} ng√†y, {people_count} ng∆∞·ªùi).

C√ÅC KH√ÅCH S·∫†N KH·∫¢ D·ª§NG:
{chr(10).join(hotel_list)}

USER BUDGET: {budget if budget else 'Ch∆∞a r√µ (gi·∫£ ƒë·ªãnh: trung b√¨nh)'}
USER MESSAGE: "{user_message}"

H√ÉY CH·ªåN KH√ÅCH S·∫†N PH√ô H·ª¢P NH·∫§T:
- N·∫øu budget th·∫•p/ti·∫øt ki·ªám ‚Üí ch·ªçn kh√°ch s·∫°n r·∫ª nh·∫•t
- N·∫øu budget trung b√¨nh/kh√¥ng ƒë·ªÅ c·∫≠p ‚Üí ch·ªçn kh√°ch s·∫°n gi√° trung b√¨nh (v·ªã tr√≠ 2-3)
- N·∫øu budget cao/sang tr·ªçng ‚Üí ch·ªçn kh√°ch s·∫°n ƒë·∫Øt nh·∫•t

Tr·∫£ v·ªÅ JSON:
{{"hotel_index": <s·ªë th·ª© t·ª± 1-5>, "reason": "<l√Ω do ng·∫Øn g·ªçn>"}}"""

                    llm_response = self.llm.complete(prompt, temperature=0.3, max_tokens=100)
                    
                    # Parse LLM response
                    import json
                    import re
                    json_match = re.search(r'\{.*\}', llm_response, re.DOTALL)
                    if json_match:
                        result = json.loads(json_match.group())
                        hotel_index = result.get('hotel_index', 2) - 1  # Convert to 0-based
                        reason = result.get('reason', 'Ph√π h·ª£p v·ªõi ng√¢n s√°ch')
                        
                        # Validate index
                        if 0 <= hotel_index < len(last_hotels):
                            selected_hotel_data = last_hotels[hotel_index]
                            selected_hotel = selected_hotel_data.get('name')
                            selected_hotel_price = selected_hotel_data.get('price')
                            
                            # Update context
                            context.selected_hotel = selected_hotel
                            context.selected_hotel_price = selected_hotel_price
                            
                            logger.info(f"‚úÖ [FIX 3] Auto-selected: {selected_hotel} - {selected_hotel_price:,} VNƒê")
                            logger.info(f"üìù Reason: {reason}")
                        else:
                            raise ValueError(f"Invalid hotel_index: {hotel_index}")
                    else:
                        raise ValueError("No JSON in LLM response")
                        
                except Exception as llm_error:
                    logger.warning(f"‚ö†Ô∏è [FIX 3] LLM auto-select failed: {llm_error}, using median price")
                    # Fallback: Select middle-price hotel
                    if last_hotels:
                        middle_index = len(last_hotels) // 2
                        selected_hotel_data = last_hotels[middle_index]
                        selected_hotel = selected_hotel_data.get('name')
                        selected_hotel_price = selected_hotel_data.get('price')
                        context.selected_hotel = selected_hotel
                        context.selected_hotel_price = selected_hotel_price
                        logger.info(f"‚úÖ [FIX 3] Fallback selected: {selected_hotel} - {selected_hotel_price:,} VNƒê")
            
            # OLD BLOCKING CODE REMOVED - Now we auto-select instead of blocking
            
            # Get prices based on location and context
            default_prices = self._get_location_default_prices(location)
            
            # Use selected hotel price if available
            selected_hotel_price = getattr(context, 'selected_hotel_price', None)
            hotel_price = selected_hotel_price if selected_hotel_price else default_prices['hotel']
            
            if selected_hotel and selected_hotel_price:
                logger.info(f"üí∞ Using selected hotel: {selected_hotel} - {selected_hotel_price:,} VNƒê/ƒë√™m")
            
            # Calculate per-day costs
            daily_costs = []
            total_cost = 0
            
            for day_num in range(1, duration + 1):
                is_last_day = (day_num == duration)
                is_first_day = (day_num == 1)
                
                # Accommodation (not on last day - going home)
                if is_last_day:
                    accommodation = 0
                    accommodation_note = "V·ªÅ nh√†"
                else:
                    accommodation = hotel_price
                    accommodation_note = selected_hotel if selected_hotel else "Kh√°ch s·∫°n"
                
                # Food
                food = default_prices['food']
                
                # Transport (higher on first/last day for airport)
                if is_first_day or is_last_day:
                    transport = default_prices.get('transport', 250000) + 125000  # Airport transfer
                    transport_note = "Di chuy·ªÉn + s√¢n bay"
                else:
                    transport = default_prices.get('transport', 250000)
                    transport_note = "Di chuy·ªÉn n·ªôi th√†nh"
                
                # Activities
                activity = default_prices.get('activity', 200000)
                
                day_total = accommodation + food + transport + activity
                total_cost += day_total
                
                daily_costs.append({
                    "day": day_num,
                    "accommodation": accommodation,
                    "accommodation_note": accommodation_note,
                    "food": food,
                    "transport": transport,
                    "transport_note": transport_note,
                    "activity": activity,
                    "total": day_total
                })
            
            # FIX 3: Format response with auto-selection notice
            nights = duration - 1
            hotel_info = ""
            auto_select_notice = ""
            
            if selected_hotel and selected_hotel_price:
                hotel_info = f"\nüè® Kh√°ch s·∫°n: **{selected_hotel}** ({selected_hotel_price:,} VNƒê/ƒë√™m)"
                
                # Check if this was auto-selected (not manually chosen by user)
                if not getattr(context, 'user_selected_hotel', False):
                    auto_select_notice = "\n\nüí° *T√¥i ƒë√£ t·ª± ƒë·ªông ch·ªçn kh√°ch s·∫°n ph√π h·ª£p v·ªõi ng√¢n s√°ch c·ªßa b·∫°n. B·∫°n c√≥ th·ªÉ thay ƒë·ªïi b·∫±ng c√°ch ch·ªçn kh√°ch s·∫°n kh√°c!*"
            
            cost_breakdown = f"üí∞ **Chi ph√≠ ∆∞·ªõc t√≠nh cho {duration} ng√†y t·∫°i {location}**{hotel_info}{auto_select_notice}\n\n"
            
            for day in daily_costs:
                cost_breakdown += f"üìÖ **Ng√†y {day['day']}:**\n"
                if day['accommodation'] > 0:
                    cost_breakdown += f"  ‚Ä¢ üè® L∆∞u tr√∫ ({day['accommodation_note']}): {day['accommodation']:,} VNƒê\n"
                else:
                    cost_breakdown += f"  ‚Ä¢ üè† L∆∞u tr√∫: {day['accommodation_note']}\n"
                cost_breakdown += f"  ‚Ä¢ üçú ƒÇn u·ªëng: {day['food']:,} VNƒê\n"
                cost_breakdown += f"  ‚Ä¢ üöó Di chuy·ªÉn ({day['transport_note']}): {day['transport']:,} VNƒê\n"
                cost_breakdown += f"  ‚Ä¢ üéØ Tham quan: {day['activity']:,} VNƒê\n"
                cost_breakdown += f"  üíµ **T·ªïng ng√†y {day['day']}: {day['total']:,} VNƒê**\n\n"
            
            cost_breakdown += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            cost_breakdown += f"üíµ **T·ªîNG CHI PH√ç: {total_cost:,} VNƒê**\n"
            cost_breakdown += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            cost_breakdown += f"üí° *Chi ph√≠ tr√™n l√† ∆∞·ªõc t√≠nh cho 1 ng∆∞·ªùi. Th·ª±c t·∫ø c√≥ th·ªÉ dao ƒë·ªông ¬±20% t√πy v√†o l·ª±a ch·ªçn d·ªãch v·ª•.*"
            
            return {
                "reply": cost_breakdown,
                "ui_type": "cost_breakdown",
                "ui_data": {
                    "location": location,
                    "duration": duration,
                    "daily_costs": daily_costs,
                    "total_cost": total_cost,
                    "selected_hotel": selected_hotel,
                    "selected_hotel_price": selected_hotel_price
                },
                "context": context.to_dict(),
                "status": "complete"
            }
            
        except Exception as e:
            logger.error(f"‚ùå Cost calculation error: {e}")
            import traceback
            traceback.print_exc()
            return {
                "reply": "Xin l·ªói, ƒë√£ c√≥ l·ªói khi t√≠nh to√°n chi ph√≠. B·∫°n c√≥ th·ªÉ th·ª≠ l·∫°i kh√¥ng? üôè",
                "ui_type": "error",
                "context": context.to_dict(),
                "status": "error"
            }
    
    def _handle_location_tips_sync(self, multi_intent, context, user_message: str) -> Optional[Dict[str, Any]]:
        """
        Handle get_location_tips intent - provide tips/advice for selected spots
        Context-aware: Uses selected_spots from itinerary_builder or last_itinerary
        """
        try:
            # Get selected spots from context
            selected_spots = []
            
            # Check itinerary builder
            builder = getattr(context, 'itinerary_builder', None)
            if builder:
                days_plan = builder.get("days_plan", {})
                for day_spots in days_plan.values():
                    selected_spots.extend(day_spots)
            
            # Check last itinerary
            if not selected_spots:
                last_itinerary = getattr(context, 'last_itinerary', None)
                if last_itinerary and isinstance(last_itinerary, dict):
                    for day in last_itinerary.get("days", []):
                        for activity in day.get("activities", []):
                            if activity.get("location"):
                                selected_spots.append({"name": activity["location"]})
            
            if not selected_spots:
                return {
                    "reply": "B·∫°n ch∆∞a ch·ªçn ƒë·ªãa ƒëi·ªÉm n√†o c·∫£. H√£y ch·ªçn ƒë·ªãa ƒëi·ªÉm tr∆∞·ªõc, sau ƒë√≥ t√¥i s·∫Ω cung c·∫•p c√°c l∆∞u √Ω h·ªØu √≠ch! üòä",
                    "ui_type": "text",
                    "context": context.to_dict(),
                    "status": "partial"
                }
            
            # FIX 2: Build tips response with LLM reasoning (Context Injection)
            spot_names = [s.get("name") for s in selected_spots[:10]]  # Max 10 spots for LLM context
            location = multi_intent.location or context.destination or "ƒëi·ªÉm ƒë·∫øn"
            
            # Try LLM-generated context-aware tips first
            tips_reply = None
            if self.llm:
                try:
                    # Prepare spot details for better context
                    spot_details = []
                    for spot in selected_spots[:10]:
                        name = spot.get("name", "")
                        category = spot.get("category", "ƒë·ªãa ƒëi·ªÉm")
                        spot_details.append(f"- {name} ({category})")
                    
                    prompt = f"""B·∫°n l√† chuy√™n gia du l·ªãch t∆∞ v·∫•n cho kh√°ch Vi·ªát Nam.

USER V·ª™A L·∫¨P L·ªäCH TR√åNH ƒêI {location.upper()}:
{chr(10).join(spot_details)}

USER H·ªéI: "{user_message}"

H√ÉY ƒê∆ØA RA C√ÅC L∆ØU √ù THI·∫æT TH·ª∞C CHO T·ª™NG ƒê·ªäA ƒêI·ªÇM:

1. üéØ **L∆∞u √Ω theo t·ª´ng ƒë·ªãa ƒëi·ªÉm c·ª• th·ªÉ** (d·ª±a v√†o danh s√°ch tr√™n):
   - Th·ªùi gian t·ªët nh·∫•t ƒë·ªÉ ƒë·∫øn
   - ƒêi·ªÅu c·∫ßn chu·∫©n b·ªã ƒë·∫∑c bi·ªát
   - M·∫πo nh·ªè khi tham quan

2. üí° **L∆∞u √Ω chung cho chuy·∫øn ƒëi:**
   - Th·ªùi ti·∫øt v√† trang ph·ª•c
   - Di chuy·ªÉn gi·ªØa c√°c ƒëi·ªÉm
   - ƒê·ªì ƒÉn v√† n∆∞·ªõc u·ªëng
   - An to√†n v√† s·ª©c kh·ªèe

3. üí∞ **Ti·∫øt ki·ªám chi ph√≠:**
   - Combo v√© (n·∫øu c√≥)
   - Gi·ªù v√†ng gi·∫£m gi√°
   - Qu√°n ƒÉn ƒë·ªãa ph∆∞∆°ng

Tr·∫£ l·ªùi ng·∫Øn g·ªçn, d·ªÖ ƒë·ªçc, d√πng emoji. T·ªëi ƒëa 400 t·ª´."""
                    
                    logger.info(f"ü§ñ [FIX 2] Generating LLM tips for {len(selected_spots)} spots")
                    llm_tips = self.llm.complete(prompt, temperature=0.7, max_tokens=600)
                    
                    if llm_tips and len(llm_tips.strip()) > 50:
                        tips_reply = f"""üìù **L∆ØU √ù CHO CHUY·∫æN ƒêI {location.upper()}**

{llm_tips.strip()}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üí¨ **B·∫°n mu·ªën l√†m g√¨ ti·∫øp theo?**

üè® **1. T√¨m kh√°ch s·∫°n** - G√µ: "t√¨m kh√°ch s·∫°n"
üí∞ **2. T√≠nh chi ph√≠** - G√µ: "t√≠nh ti·ªÅn"
üìã **3. Xem l·∫°i l·ªãch tr√¨nh** - G√µ: "xem l·∫°i l·ªãch tr√¨nh"
üìç **4. Chi ti·∫øt ƒë·ªãa ƒëi·ªÉm** - G√µ: "chi ti·∫øt v·ªÅ [t√™n ƒë·ªãa ƒëi·ªÉm]"

C·∫ßn th√™m th√¥ng tin g√¨ kh√¥ng? üòä"""
                        logger.info("‚úÖ [FIX 2] LLM tips generated successfully")
                        
                except Exception as llm_error:
                    logger.warning(f"‚ö†Ô∏è [FIX 2] LLM tips failed: {llm_error}, using generic fallback")
                    tips_reply = None
            
            # Fallback to generic tips if LLM unavailable or failed
            if not tips_reply:
                logger.info("‚ÑπÔ∏è [FIX 2] Using generic tips (LLM unavailable or failed)")
                tips_reply = f"""üìù **L∆ØU √ù KHI ƒê·∫æN C√ÅC ƒê·ªäA ƒêI·ªÇM T·∫†I {location.upper()}**

üéØ **C√°c ƒë·ªãa ƒëi·ªÉm b·∫°n ƒë√£ ch·ªçn:**
{chr(10).join([f"  ‚Ä¢ {name}" for name in spot_names])}

üí° **L∆∞u √Ω chung:**
‚Ä¢ ‚è∞ **Th·ªùi gian t·ªët nh·∫•t:** Kh·ªüi h√†nh s·ªõm (7-8h s√°ng) ƒë·ªÉ tr√°nh n·∫Øng v√† ƒë√¥ng ƒë√∫c
‚Ä¢ üß¥ **Chu·∫©n b·ªã:** Kem ch·ªëng n·∫Øng, n√≥n, n∆∞·ªõc u·ªëng, gi√†y tho·∫£i m√°i
‚Ä¢ üí∞ **Ti·ªÅn m·∫∑t:** Mang theo ti·ªÅn l·∫ª cho v√© v√†o c·ª≠a v√† mua n∆∞·ªõc
‚Ä¢ üì∏ **Ch·ª•p ·∫£nh:** Gi·ªù v√†ng (6-7h s√°ng ho·∫∑c 5-6h chi·ªÅu) cho √°nh s√°ng ƒë·∫πp nh·∫•t

üé´ **V√© tham quan:**
‚Ä¢ Nhi·ªÅu ƒë·ªãa ƒëi·ªÉm c√≥ gi√° v√© combo ti·∫øt ki·ªám h∆°n
‚Ä¢ Sinh vi√™n nh·ªõ mang th·∫ª ƒë·ªÉ ƒë∆∞·ª£c gi·∫£m gi√° 50%

üöó **Di chuy·ªÉn:**
‚Ä¢ Grab/Taxi: Ti·ªán l·ª£i nh·∫•t cho nh√≥m 2-4 ng∆∞·ªùi
‚Ä¢ Thu√™ xe m√°y: Linh ho·∫°t, kho·∫£ng 100-150k/ng√†y
‚Ä¢ Xe bus: Ti·∫øt ki·ªám nh·∫•t, c√≥ app Danang Fantasticity

üçú **·∫®m th·ª±c:**
‚Ä¢ ƒÇn t·∫°i qu√°n ƒë·ªãa ph∆∞∆°ng g·∫ßn c√°c ƒëi·ªÉm tham quan ƒë·ªÉ ti·∫øt ki·ªám
‚Ä¢ N√™n ƒÉn tr∆∞a t·ª´ 11h30-12h ƒë·ªÉ tr√°nh qu√° ƒë√≥i

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

ÔøΩ **B·∫°n mu·ªën l√†m g√¨ ti·∫øp theo?**

üè® **1. T√¨m kh√°ch s·∫°n** - G√µ: "t√¨m kh√°ch s·∫°n"
üí∞ **2. T√≠nh chi ph√≠** - G√µ: "t√≠nh ti·ªÅn"
üìã **3. Xem l·∫°i l·ªãch tr√¨nh** - G√µ: "xem l·∫°i l·ªãch tr√¨nh"
üìç **4. Chi ti·∫øt ƒë·ªãa ƒëi·ªÉm** - G√µ: "chi ti·∫øt v·ªÅ [t√™n ƒë·ªãa ƒëi·ªÉm]"

C·∫ßn th√™m th√¥ng tin g√¨ kh√¥ng? üòä"""

            return {
                "reply": tips_reply,
                "ui_type": "tips",
                "ui_data": {
                    "selected_spots": spot_names,
                    "location": location,
                    "tips_categories": [
                        {"icon": "‚è∞", "title": "Th·ªùi gian", "content": "Kh·ªüi h√†nh s·ªõm 7-8h"},
                        {"icon": "üß¥", "title": "Chu·∫©n b·ªã", "content": "Kem ch·ªëng n·∫Øng, n√≥n, n∆∞·ªõc"},
                        {"icon": "üí∞", "title": "Ti·ªÅn m·∫∑t", "content": "Mang ti·ªÅn l·∫ª cho v√©"},
                        {"icon": "üì∏", "title": "Ch·ª•p ·∫£nh", "content": "Golden hour 6-7h ho·∫∑c 5-6h"},
                        {"icon": "üé´", "title": "V√©", "content": "V√© combo ti·∫øt ki·ªám, SV gi·∫£m 50%"},
                        {"icon": "üöó", "title": "Di chuy·ªÉn", "content": "Grab/Taxi ho·∫∑c thu√™ xe m√°y"},
                        {"icon": "üçú", "title": "·∫®m th·ª±c", "content": "Qu√°n ƒë·ªãa ph∆∞∆°ng ngon + r·∫ª"}
                    ],
                    # CRITICAL: Add action buttons matching frontend format
                    "actions": [
                        {"label": "üè® T√¨m kh√°ch s·∫°n", "action": "t√¨m kh√°ch s·∫°n"},
                        {"label": "üí∞ T√≠nh chi ph√≠", "action": "t√≠nh ti·ªÅn"},
                        {"label": "üìã Xem l·∫°i l·ªãch tr√¨nh", "action": "xem l·∫°i l·ªãch tr√¨nh"}
                    ]
                },
                "context": context.to_dict(),
                "status": "success"
            }
            
        except Exception as e:
            logger.error(f"‚ùå Location tips error: {e}")
            import traceback
            traceback.print_exc()
            return {
                "reply": "Xin l·ªói, kh√¥ng th·ªÉ l·∫•y th√¥ng tin l∆∞u √Ω l√∫c n√†y. B·∫°n h√£y th·ª≠ l·∫°i nh√©! üôè",
                "ui_type": "error",
                "context": context.to_dict(),
                "status": "error"
            }
    
    def _handle_detail_request_sync(self, multi_intent, context, user_message: str) -> Optional[Dict[str, Any]]:
        """Handle get_detail intent synchronously - show detailed info about a spot/hotel"""
        try:
            entity_name = None
            entity_data = None
            entity_type = None
            
            # Get last shown spots and hotels from context
            last_spots = getattr(context, 'last_spots', []) or []
            last_hotels = getattr(context, 'last_hotels', []) or []
            
            message_lower = user_message.lower()
            
            # Check for ordinal references like "ƒë·∫ßu ti√™n", "th·ª© 2", "s·ªë 1"
            ordinal_index = self._extract_ordinal_index(message_lower)
            if ordinal_index is not None:
                # User is referring to an item by position
                if last_spots and ordinal_index < len(last_spots):
                    entity_data = last_spots[ordinal_index]
                    entity_name = entity_data.get("name")
                    entity_type = "spot"
                    logger.info(f"üìç Found by ordinal #{ordinal_index + 1}: {entity_name}")
                elif last_hotels and ordinal_index < len(last_hotels):
                    entity_data = last_hotels[ordinal_index]
                    entity_name = entity_data.get("name")
                    entity_type = "hotel"
                    logger.info(f"üè® Found by ordinal #{ordinal_index + 1}: {entity_name}")
            
            # Search in spots from context by name match
            if not entity_name:
                for spot in last_spots:
                    name = spot.get("name", "").lower()
                    if name and name in message_lower:
                        entity_name = spot.get("name")
                        entity_data = spot
                        entity_type = "spot"
                        break
            
            # Search in hotels if not found in spots
            if not entity_name:
                for hotel in last_hotels:
                    name = hotel.get("name", "").lower()
                    if name and name in message_lower:
                        entity_name = hotel.get("name")
                        entity_data = hotel
                        entity_type = "hotel"
                        break
            
            # If not found in context, search directly in database
            if not entity_name and self.mongo_manager:
                # Try to extract spot/hotel name from message
                keywords = multi_intent.keywords if multi_intent.keywords else []
                
                # Also try to extract entity name from "chi ti·∫øt v·ªÅ X" patterns
                extracted_name = self._extract_entity_name_from_message(user_message)
                if extracted_name and extracted_name not in keywords:
                    keywords = [extracted_name] + keywords
                
                for kw in keywords:
                    entity_data, entity_type = self._search_entity_in_db_sync(kw.lower(), multi_intent.location)
                    if entity_data:
                        entity_name = entity_data.get("name")
                        break
                
                # If still not found, try searching with location context
                if not entity_name and extracted_name and multi_intent.location:
                    entity_data, entity_type = self._search_entity_in_db_combined(
                        extracted_name, 
                        multi_intent.location
                    )
                    if entity_data:
                        entity_name = entity_data.get("name")
            
            if entity_name and entity_data:
                # Format detailed response
                detail_response = self._format_entity_detail_sync(entity_name, entity_data, entity_type)
                detail_response["context"] = context.to_dict()
                return detail_response
            
            # Entity not found - provide helpful response
            location = multi_intent.location or getattr(context, 'destination', None)
            return {
                "reply": f"T√¥i ch∆∞a t√¨m th·∫•y th√¥ng tin chi ti·∫øt v·ªÅ ƒë·ªãa ƒëi·ªÉm n√†y.\n\n"
                         f"üí° B·∫°n c√≥ th·ªÉ:\n"
                         f"‚Ä¢ Ch·ªçn t·ª´ danh s√°ch ƒë·ªãa ƒëi·ªÉm ƒë√£ g·ª£i √Ω\n"
                         f"‚Ä¢ H·ªèi: 'ƒê·ªãa ƒëi·ªÉm tham quan ·ªü {location or 'X'}'\n"
                         f"‚Ä¢ Ho·∫∑c n√≥i r√µ t√™n ƒë·ªãa ƒëi·ªÉm b·∫°n quan t√¢m",
                "ui_type": "none",
                "context": context.to_dict(),
                "status": "partial"
            }
            
        except Exception as e:
            logger.error(f"‚ùå Detail request error: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    def _search_entity_in_db_sync(self, search_phrase: str, location: str = None) -> tuple:
        """Search for entity in database synchronously
        
        Supports both Vietnamese diacritics and non-diacritic (ASCII) search.
        Uses unidecode for normalization when direct regex fails.
        """
        if not self.mongo_manager:
            return None, None
        
        try:
            from unidecode import unidecode
        except ImportError:
            unidecode = None
        
        # Normalize search phrase
        search_lower = search_phrase.lower().strip()
        search_normalized = unidecode(search_lower) if unidecode else search_lower
        
        # Try spots collection first
        spots_col = self.mongo_manager.get_collection("spots_detailed")
        if spots_col is not None:
            # First try: direct regex match
            spot = spots_col.find_one({
                "name": {"$regex": search_phrase, "$options": "i"}
            })
            
            # Second try: search with normalized comparison (for non-diacritic queries)
            if not spot and unidecode:
                # Get candidates from location if available
                query = {}
                if location:
                    # Normalize location to province_id format
                    province_id = location.lower().replace(" ", "-")
                    province_id = unidecode(province_id).replace(" ", "-")
                    query["province_id"] = province_id
                
                # Search through candidates
                candidates = spots_col.find(query).limit(500)
                for candidate in candidates:
                    name = candidate.get("name", "")
                    name_normalized = unidecode(name.lower())
                    # Check if search phrase is contained in normalized name
                    if search_normalized in name_normalized:
                        spot = candidate
                        logger.info(f"‚úÖ Found spot via normalized search: '{search_phrase}' -> '{name}'")
                        break
            
            if spot:
                spot = _clean_mongo_doc(spot)
                logger.info(f"‚úÖ Found spot in DB: {spot.get('name')}")
                return spot, "spot"
        
        # Try hotels collection
        hotels_col = self.mongo_manager.get_collection("hotels")
        if hotels_col is not None:
            # First try: direct regex match
            hotel = hotels_col.find_one({
                "name": {"$regex": search_phrase, "$options": "i"}
            })
            
            # Second try: normalized search
            if not hotel and unidecode:
                query = {}
                if location:
                    province_id = location.lower().replace(" ", "-")
                    province_id = unidecode(province_id).replace(" ", "-")
                    query["province_id"] = province_id
                
                candidates = hotels_col.find(query).limit(500)
                for candidate in candidates:
                    name = candidate.get("name", "")
                    name_normalized = unidecode(name.lower())
                    if search_normalized in name_normalized:
                        hotel = candidate
                        logger.info(f"‚úÖ Found hotel via normalized search: '{search_phrase}' -> '{name}'")
                        break
            
            if hotel:
                hotel = _clean_mongo_doc(hotel)
                logger.info(f"‚úÖ Found hotel in DB: {hotel.get('name')}")
                return hotel, "hotel"
        
        return None, None
    
    def _extract_entity_name_from_message(self, message: str) -> Optional[str]:
        """Extract entity name from 'chi ti·∫øt v·ªÅ X' pattern"""
        import re
        
        # Patterns to extract entity name (both with and without Vietnamese diacritics)
        patterns = [
            # With diacritics
            r'chi ti·∫øt v·ªÅ (.+?)(?:\s+·ªü\s+|\s+t·∫°i\s+|\s*$)',
            r'th√¥ng tin v·ªÅ (.+?)(?:\s+·ªü\s+|\s+t·∫°i\s+|\s*$)',
            r'cho t√¥i bi·∫øt v·ªÅ (.+?)(?:\s+·ªü\s+|\s+t·∫°i\s+|\s*$)',
            r'n√≥i v·ªÅ (.+?)(?:\s+·ªü\s+|\s+t·∫°i\s+|\s*$)',
            r'gi·ªõi thi·ªáu v·ªÅ (.+?)(?:\s+·ªü\s+|\s+t·∫°i\s+|\s*$)',
            # Without diacritics
            r'chi tiet ve (.+?)(?:\s+o\s+|\s+tai\s+|\s*$)',
            r'thong tin ve (.+?)(?:\s+o\s+|\s+tai\s+|\s*$)',
            r'cho toi biet ve (.+?)(?:\s+o\s+|\s+tai\s+|\s*$)',
            r'noi ve (.+?)(?:\s+o\s+|\s+tai\s+|\s*$)',
            r'gioi thieu ve (.+?)(?:\s+o\s+|\s+tai\s+|\s*$)',
        ]
        
        message_lower = message.lower()
        for pattern in patterns:
            match = re.search(pattern, message_lower, re.IGNORECASE)
            if match:
                entity_name = match.group(1).strip()
                # Remove trailing punctuation
                entity_name = entity_name.rstrip(',.?!')
                logger.info(f"üìù Extracted entity name: '{entity_name}' from message")
                return entity_name
        
        return None
    
    def _search_entity_in_db_combined(self, entity_name: str, location: str) -> tuple:
        """Search for entity with combined name + location"""
        if not self.mongo_manager:
            return None, None
        
        spots_col = self.mongo_manager.get_collection("spots_detailed")
        if spots_col is not None:
            # Search with both name and location (province)
            # Try: name contains entity_name AND (province contains location OR address contains location)
            query = {
                "$and": [
                    {"name": {"$regex": entity_name, "$options": "i"}},
                    {"$or": [
                        {"province": {"$regex": location, "$options": "i"}},
                        {"address": {"$regex": location, "$options": "i"}},
                        {"location": {"$regex": location, "$options": "i"}}
                    ]}
                ]
            }
            
            # Get best match by score (if available)
            spots = list(spots_col.find(query).sort([("score", -1)]).limit(1))
            if spots:
                spot = _clean_mongo_doc(spots[0])
                logger.info(f"‚úÖ Found spot with location filter: {spot.get('name')}")
                return spot, "spot"
            
            # Fallback: just search by name
            spot = spots_col.find_one({"name": {"$regex": entity_name, "$options": "i"}})
            if spot:
                spot = _clean_mongo_doc(spot)
                logger.info(f"‚úÖ Found spot by name only: {spot.get('name')}")
                return spot, "spot"
        
        return None, None
    
    def _format_entity_detail_sync(self, name: str, data: dict, entity_type: str) -> Dict[str, Any]:
        """Format detailed entity information synchronously"""
        if entity_type == "spot":
            # Check multiple possible description fields (based on actual DB structure)
            description = (
                data.get("description_full") or 
                data.get("description") or 
                data.get("introduction") or 
                data.get("teaser_review") or
                data.get("description_short") or
                "ƒêi·ªÉm tham quan h·∫•p d·∫´n"
            )
            address = data.get("address") or data.get("location") or ""
            rating = data.get("rating") or 4.0
            category = data.get("category") or "ƒê·ªãa ƒëi·ªÉm tham quan"
            reviews_count = data.get("reviews_count", 0)
            image = data.get("image", "")
            url = data.get("url", "")
            
            reply = f"üìç **{name}**\n\n"
            reply += f"üìù **M√¥ t·∫£:**\n{description}\n\n"
            if address:
                reply += f"üìå **ƒê·ªãa ch·ªâ:** {address}\n"
            if rating and rating > 0:
                reply += f"‚≠ê **ƒê√°nh gi√°:** {rating}/5"
                if reviews_count:
                    reply += f" ({reviews_count:,} ƒë√°nh gi√°)"
                reply += "\n"
            if category and category != "None":
                reply += f"üè∑Ô∏è **Lo·∫°i:** {category}\n"
            if url:
                reply += f"üîó **Xem th√™m:** [Chi ti·∫øt]({url})\n"
            reply += f"\nüí° *B·∫°n c√≥ mu·ªën xem th√™m ƒë·ªãa ƒëi·ªÉm kh√°c ho·∫∑c l√™n l·ªãch tr√¨nh kh√¥ng?*"
            
            return {
                "reply": reply,
                "ui_type": "spot_detail",
                "ui_data": {
                    "name": name,
                    "type": "spot",
                    "image": image,
                    "data": data
                },
                "status": "complete"
            }
        
        elif entity_type == "hotel":
            price = data.get("price", 0)
            address = data.get("address", "")
            rating = data.get("rating", 4.0)
            amenities = data.get("amenities", [])
            
            reply = f"üè® **{name}**\n\n"
            if price:
                reply += f"üíµ **Gi√°:** {price:,} VNƒê/ƒë√™m\n"
            if address:
                reply += f"üìå **ƒê·ªãa ch·ªâ:** {address}\n"
            reply += f"‚≠ê **ƒê√°nh gi√°:** {rating}/10\n"
            if amenities:
                reply += f"üõéÔ∏è **Ti·ªán √≠ch:** {', '.join(amenities[:5])}\n"
            reply += f"\nüí° *B·∫°n c√≥ mu·ªën ƒë·∫∑t ph√≤ng t·∫°i ƒë√¢y kh√¥ng? H·ªèi: 'ƒê·∫∑t ph√≤ng t·∫°i {name}'*"
            
            return {
                "reply": reply,
                "ui_type": "hotel_detail",
                "ui_data": {
                    "name": name,
                    "type": "hotel",
                    "data": data
                },
                "status": "complete"
            }
        
        return {
            "reply": f"üìå **{name}**\n\n{data.get('description', 'Kh√¥ng c√≥ m√¥ t·∫£')}",
            "ui_type": "detail",
            "status": "complete"
        }
    
    async def _handle_special_intent(
        self, 
        multi_intent, 
        context, 
        user_message: str
    ) -> Optional[Dict[str, Any]]:
        """
        Handle special intents that don't require task planning
        
        Returns response dict or None if normal processing should continue
        """
        intent = multi_intent.primary_intent
        
        # === CHECK FOR ITINERARY BUILDER STATE FIRST ===
        # If user is in the middle of interactive itinerary building
        if hasattr(context, 'itinerary_builder') and context.itinerary_builder:
            logger.info("üóìÔ∏è [ASYNC] User in itinerary builder mode, processing selection...")
            builder_response = self._continue_interactive_itinerary_sync(user_message, context)
            if builder_response:
                return builder_response
        
        # === GREETING ===
        if intent == "greeting":
            return {
                "reply": "Xin ch√†o! üëã T√¥i l√† Saola - tr·ª£ l√Ω du l·ªãch AI c·ªßa b·∫°n. "
                         "T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n"
                         "‚Ä¢ üó∫Ô∏è L√™n l·ªãch tr√¨nh du l·ªãch\n"
                         "‚Ä¢ üè® T√¨m kh√°ch s·∫°n ph√π h·ª£p\n"
                         "‚Ä¢ üìç G·ª£i √Ω ƒë·ªãa ƒëi·ªÉm tham quan\n"
                         "‚Ä¢ üçú Kh√°m ph√° ·∫©m th·ª±c ƒë·ªãa ph∆∞∆°ng\n"
                         "‚Ä¢ üí∞ ∆Ø·ªõc t√≠nh chi ph√≠ chuy·∫øn ƒëi\n\n"
                         "B·∫°n mu·ªën ƒëi ƒë√¢u? üåç",
                "ui_type": "greeting",
                "context": context.to_dict(),
                "status": "partial"
            }
        
        # === CHITCHAT / OFF-TOPIC ===
        if intent == "chitchat":
            return {
                "reply": "T√¥i l√† Saola - tr·ª£ l√Ω du l·ªãch AI! ü¶å\n\n"
                         "T√¥i chuy√™n v·ªÅ du l·ªãch Vi·ªát Nam v√† c√≥ th·ªÉ gi√∫p b·∫°n:\n"
                         "‚Ä¢ L√™n k·∫ø ho·∫°ch chuy·∫øn ƒëi\n"
                         "‚Ä¢ T√¨m kh√°ch s·∫°n t·ªët nh·∫•t\n"
                         "‚Ä¢ G·ª£i √Ω ƒëi·ªÉm ƒë·∫øn h·∫•p d·∫´n\n\n"
                         "H√£y cho t√¥i bi·∫øt b·∫°n mu·ªën ƒëi ƒë√¢u nh√©! üó∫Ô∏è",
                "ui_type": "chitchat",
                "context": context.to_dict(),
                "status": "partial"
            }
        
        # === THANKS ===
        if intent == "thanks":
            return {
                "reply": "Kh√¥ng c√≥ g√¨ ·∫°! üòä R·∫•t vui ƒë∆∞·ª£c gi√∫p ƒë·ª° b·∫°n. "
                         "N·∫øu c·∫ßn h·ªó tr·ª£ th√™m v·ªÅ chuy·∫øn ƒëi, c·ª© h·ªèi t√¥i nh√©! ‚úàÔ∏è",
                "ui_type": "thanks",
                "context": context.to_dict(),
                "status": "partial"
            }
        
        # === FAREWELL ===
        if intent == "farewell":
            return {
                "reply": "T·∫°m bi·ªát b·∫°n! üëã Ch√∫c b·∫°n c√≥ chuy·∫øn ƒëi th·∫≠t vui v·∫ª! "
                         "H·∫πn g·∫∑p l·∫°i l·∫ßn sau! üåü",
                "ui_type": "farewell",
                "context": context.to_dict(),
                "status": "partial"
            }
        
        # === BOOKING REQUEST ===
        if intent == "book_hotel":
            try:
                hotel_name = multi_intent.keywords[0] if multi_intent.keywords else None
                location = getattr(context, 'destination', None)
                
                logger.info(f"üìç Book hotel request: hotel_name={hotel_name}, location={location}")
                logger.info(f"üìç Keywords from intent: {multi_intent.keywords}")
                
                if hotel_name:
                    # Store selected hotel in context
                    context.selected_hotel = hotel_name
                    
                    # Try to get hotel URL and price from database
                    hotel_url = None
                    hotel_price = None
                    
                    # First, try to find hotel in last_hotels context (from previous search)
                    if hasattr(context, 'last_hotels') and context.last_hotels:
                        for hotel in context.last_hotels:
                            hotel_name_in_list = hotel.get("name", "")
                            if hotel_name.lower() in hotel_name_in_list.lower() or hotel_name_in_list.lower() in hotel_name.lower():
                                hotel_price = hotel.get("price")
                                hotel_url = hotel.get("url")
                                logger.info(f"‚úÖ Found hotel in context.last_hotels: {hotel_name_in_list}, price: {hotel_price}")
                                break
                    
                    # If not found in context, search database
                    if not hotel_price and self.mongo_manager:
                        hotels_col = self.mongo_manager.get_collection("hotels")
                        if hotels_col is not None:
                            # Search for hotel by name (partial match with first word)
                            first_word = hotel_name.split()[0] if hotel_name.split() else hotel_name
                            hotel_doc = hotels_col.find_one({
                                "name": {"$regex": first_word, "$options": "i"}
                            })
                            if hotel_doc:
                                hotel_url = hotel_doc.get("url")
                                hotel_price = hotel_doc.get("price")
                                logger.info(f"‚úÖ Found hotel in DB: {hotel_doc.get('name')}")
                            else:
                                logger.info(f"‚ö†Ô∏è Hotel not found in DB, using search links only")
                    
                    # Save selected hotel price to context for cost calculation
                    if hotel_price:
                        context.selected_hotel_price = hotel_price
                        logger.info(f"üí∞ Saved selected_hotel_price to context: {hotel_price:,} VNƒê")
                    
                    # Build booking response with links
                    booking_links = []
                    if hotel_url:
                        booking_links.append(f"üîó [ƒê·∫∑t ph√≤ng t·∫°i website g·ªëc]({hotel_url})")
                    
                    # Add search links for popular booking sites
                    search_name = hotel_name.replace(" ", "+")
                    booking_links.extend([
                        f"üîó [T√¨m tr√™n Booking.com](https://www.booking.com/searchresults.html?ss={search_name})",
                        f"üîó [T√¨m tr√™n Agoda](https://www.agoda.com/search?q={search_name})",
                        f"üîó [T√¨m tr√™n Traveloka](https://www.traveloka.com/vi-vn/hotel/search?q={search_name})"
                    ])
                    
                    price_info = f"\nüí∞ Gi√° tham kh·∫£o: **{hotel_price:,} VNƒê/ƒë√™m**" if hotel_price else ""
                    
                    return {
                        "reply": f"üè® **ƒê·∫∑t ph√≤ng: {hotel_name}**{price_info}\n\n"
                                 f"üì± **C√°ch ƒë·∫∑t ph√≤ng:**\n"
                                 f"{chr(10).join(booking_links)}\n\n"
                                 f"üí° **L∆∞u √Ω khi ƒë·∫∑t ph√≤ng:**\n"
                                 f"‚Ä¢ So s√°nh gi√° gi·ªØa c√°c trang ƒë·ªÉ t√¨m ∆∞u ƒë√£i t·ªët nh·∫•t\n"
                                 f"‚Ä¢ Ki·ªÉm tra ch√≠nh s√°ch h·ªßy ph√≤ng tr∆∞·ªõc khi ƒë·∫∑t\n"
                                 f"‚Ä¢ ƒê·ªçc review g·∫ßn ƒë√¢y t·ª´ kh√°ch h√†ng\n\n"
                                 f"B·∫°n c·∫ßn t√¥i ∆∞·ªõc t√≠nh chi ph√≠ to√†n b·ªô chuy·∫øn ƒëi kh√¥ng? üí∞",
                        "ui_type": "booking",
                        "ui_data": {
                            "selected_hotel": hotel_name,
                            "hotel_url": hotel_url,
                            "hotel_price": hotel_price,
                            "booking_links": booking_links
                        },
                        "status": "partial",
                        "context": context.to_dict()
                    }
                else:
                    return {
                        "reply": "B·∫°n mu·ªën ƒë·∫∑t ph√≤ng kh√°ch s·∫°n n√†o? üè®\n"
                                 "H√£y cho t√¥i bi·∫øt t√™n kh√°ch s·∫°n b·∫°n quan t√¢m!",
                        "ui_type": "booking_prompt",
                        "context": context.to_dict(),
                        "status": "partial"
                    }
            except Exception as e:
                logger.error(f"‚ùå Book hotel error: {e}")
                import traceback
                traceback.print_exc()
                return {
                    "reply": f"üè® T√¥i ghi nh·∫≠n b·∫°n mu·ªën ƒë·∫∑t ph√≤ng.\n\n"
                             f"B·∫°n c√≥ th·ªÉ t√¨m ki·∫øm kh√°ch s·∫°n tr√™n:\n"
                             f"‚Ä¢ [Booking.com](https://www.booking.com)\n"
                             f"‚Ä¢ [Agoda](https://www.agoda.com)\n"
                             f"‚Ä¢ [Traveloka](https://www.traveloka.com)\n\n"
                             f"Ho·∫∑c cho t√¥i bi·∫øt t√™n kh√°ch s·∫°n c·ª• th·ªÉ b·∫°n mu·ªën ƒë·∫∑t!",
                    "ui_type": "booking",
                    "context": context.to_dict(),
                    "status": "partial"
                }
        
        # === COST CALCULATION (context-aware) ===
        if intent == "calculate_cost":
            return await self._handle_cost_from_context(context, multi_intent, user_message)
        
        # === GET DETAIL - User asking about specific spot/hotel ===
        if self._is_detail_request(user_message, context):
            return await self._handle_get_detail(user_message, context, multi_intent)
        
        # === BREAKDOWN - User wants cost breakdown by day ===
        if self._is_breakdown_request(user_message):
            return await self._handle_breakdown(context, multi_intent)
        
        # === CUSTOMIZE ITINERARY PER DAY - User specifies activities per day ===
        day_preferences = self._parse_day_preferences(user_message)
        if day_preferences:
            return await self._handle_customize_itinerary(day_preferences, context, multi_intent)
        
        # === REGION SEARCH - "Mi·ªÅn nam", "Mi·ªÅn b·∫Øc", etc. ===
        region = self._extract_region(user_message)
        if region:
            return await self._handle_region_search(region, context)
        
        # === RECALL ITINERARY - "Xem l·∫°i l·ªãch tr√¨nh", "L·ªãch tr√¨nh c·ªßa t√¥i" ===
        if self._is_recall_itinerary_request(user_message):
            return self._handle_recall_itinerary(context)
        
        # Not a special intent - continue normal processing
        return None
    
    def _parse_day_preferences(self, message: str) -> Optional[Dict[int, Dict]]:
        """
        Parse user's day-by-day preferences from message.
        
        Examples:
            "Ng√†y 1 mu·ªën ƒëi C·∫ßu R·ªìng, Ng√†y 2 mu·ªën ƒëi Bi·ªÉn ƒÉn h·∫£i s·∫£n, ng√†y 3 mu·ªën ƒëi ch√πa"
            -> {1: {"raw": "c·∫ßu r·ªìng", "keywords": []},
                2: {"raw": "bi·ªÉn ƒÉn h·∫£i s·∫£n", "keywords": ["h·∫£i s·∫£n"]},
                3: {"raw": "ch√πa", "keywords": []}}
        """
        import re
        
        message_lower = message.lower()
        
        # Best pattern: lookahead for next "ng√†y" or end of string
        # Handles comma/space separators and optional "mu·ªën ƒëi"
        day_pattern = r'ng√†y\s*(\d+)\s*[:\s]*(?:mu·ªën\s*)?(?:ƒëi\s*)?(.+?)(?=,?\s*ng√†y\s*\d+|$)'
        day_matches = re.findall(day_pattern, message_lower)
        
        if len(day_matches) < 2:  # Need at least 2 days to be considered day-specific
            return None
        
        preferences = {}
        
        for day_num_str, content in day_matches:
            day_num = int(day_num_str)
            content = content.strip().rstrip(',').strip()
            
            # Extract keywords
            keywords = []
            
            # Extract food keywords
            food_keywords = ["h·∫£i s·∫£n", "b√∫n", "ph·ªü", "m√¨", "b√°nh", "ƒÉn"]
            for kw in food_keywords:
                if kw in content:
                    keywords.append(kw)
            
            preferences[day_num] = {
                "raw": content,
                "activities": [content],
                "keywords": keywords
            }
        
        return preferences if preferences else None
    
    async def _handle_customize_itinerary(
        self,
        day_preferences: Dict[int, Dict],
        context,
        multi_intent
    ) -> Dict[str, Any]:
        """
        Handle user request to customize itinerary per day.
        Search for relevant spots/hotels based on their preferences for each day.
        """
        location = multi_intent.location or getattr(context, 'destination', None) or "ƒê√† N·∫µng"
        duration = len(day_preferences)
        
        # Update context
        context.destination = location
        context.duration = duration
        
        logger.info(f"üóìÔ∏è Customizing itinerary for {duration} days at {location}")
        logger.info(f"üìã Day preferences: {day_preferences}")
        
        # Build customized itinerary
        customized_days = []
        daily_costs = []
        
        for day_num in sorted(day_preferences.keys()):
            pref = day_preferences[day_num]
            raw_pref = pref.get("raw", "")
            keywords = pref.get("keywords", [])
            
            day_result = await self._build_day_itinerary(
                day_num=day_num,
                preference=raw_pref,
                keywords=keywords,
                location=location,
                is_last_day=(day_num == max(day_preferences.keys())),
                context=context
            )
            
            customized_days.append(day_result)
            # Keep day number in cost
            cost_with_day = day_result.get("cost", {}).copy()
            cost_with_day["day"] = day_num
            daily_costs.append(cost_with_day)
        
        # Format response
        response_text = self._format_customized_itinerary(
            location=location,
            days=customized_days,
            daily_costs=daily_costs
        )
        
        # Update context with new itinerary
        context.last_itinerary = {"days": customized_days}
        
        return {
            "reply": response_text,
            "ui_type": "custom_itinerary",
            "ui_data": {
                "itinerary": customized_days,
                "daily_costs": daily_costs,
                "location": location,
                "duration": duration
            },
            "context": context.to_dict(),
            "status": "complete"
        }
    
    async def _build_day_itinerary(
        self,
        day_num: int,
        preference: str,
        keywords: List[str],
        location: str,
        is_last_day: bool,
        context
    ) -> Dict:
        """Build itinerary for a single day based on user preference"""
        
        day_data = {
            "day": day_num,
            "preference": preference,
            "spots": [],
            "hotel": None,
            "food": [],
            "cost": {
                "accommodation": 0,
                "activities": 0,
                "food": 0,
                "transport": 0,
                "total": 0
            }
        }
        
        # Search for relevant spots based on preference
        spots = await self._search_spots_by_preference(preference, location)
        if spots:
            day_data["spots"] = spots[:2]  # Max 2 spots per day
            # Calculate activity cost
            for spot in day_data["spots"]:
                day_data["cost"]["activities"] += self._estimate_spot_cost(spot)
        
        # Search for food if mentioned
        if any(kw in preference for kw in ["ƒÉn", "h·∫£i s·∫£n", "qu√°n", "m√≥n"]):
            food = await self._search_food_by_preference(keywords, location)
            if food:
                day_data["food"] = food[:1]
        
        # Accommodation
        accommodation_type = self._detect_accommodation_from_preference(preference, is_last_day)
        if accommodation_type == "hotel":
            # Get default hotel price
            default_prices = self._get_location_default_prices(location)
            day_data["cost"]["accommodation"] = default_prices["hotel"]
            day_data["accommodation_note"] = "Kh√°ch s·∫°n"
        elif accommodation_type == "friend":
            day_data["cost"]["accommodation"] = 0
            day_data["accommodation_note"] = "·ªû nh√† b·∫°n b√®"
        else:
            day_data["cost"]["accommodation"] = 0
            day_data["accommodation_note"] = "V·ªÅ nh√†"
        
        # Food cost
        default_prices = self._get_location_default_prices(location)
        if "h·∫£i s·∫£n" in preference:
            day_data["cost"]["food"] = default_prices["food"] * 1.5  # Seafood is more expensive
        else:
            day_data["cost"]["food"] = default_prices["food"]
        
        # Transport cost
        day_data["cost"]["transport"] = default_prices["transport"]
        if day_num == 1 or is_last_day:
            day_data["cost"]["transport"] *= 1.5  # First/last day has more travel
        
        # Calculate total
        day_data["cost"]["total"] = (
            day_data["cost"]["accommodation"] +
            day_data["cost"]["activities"] +
            day_data["cost"]["food"] +
            day_data["cost"]["transport"]
        )
        
        return day_data
    
    async def _search_spots_by_preference(self, preference: str, location: str) -> List[Dict]:
        """Search for spots matching user preference"""
        if not self.mongo_manager:
            return []
        
        try:
            spots_col = self.mongo_manager.get_collection("spots_detailed")
            
            # Build search query
            search_terms = preference.lower().split()
            
            # Try exact match first
            for term in search_terms:
                if len(term) >= 3:
                    spots = list(spots_col.find({
                        "$and": [
                            {"name": {"$regex": term, "$options": "i"}},
                            {"$or": [
                                {"address": {"$regex": location, "$options": "i"}},
                                {"province": {"$regex": location, "$options": "i"}}
                            ]}
                        ]
                    }).limit(3))
                    
                    if spots:
                        return [_clean_mongo_doc(s) for s in spots]
            
            # Fallback: search by location only
            spots = list(spots_col.find({
                "$or": [
                    {"address": {"$regex": location, "$options": "i"}},
                    {"province": {"$regex": location, "$options": "i"}}
                ]
            }).limit(3))
            
            return [_clean_mongo_doc(s) for s in spots]
            
        except Exception as e:
            logger.error(f"‚ùå Error searching spots: {e}")
            return []
    
    async def _search_food_by_preference(self, keywords: List[str], location: str) -> List[Dict]:
        """Search for food/restaurants matching keywords"""
        # Return food suggestions based on keywords
        food_suggestions = []
        
        if "h·∫£i s·∫£n" in keywords:
            food_suggestions.append({
                "name": f"Nh√† h√†ng h·∫£i s·∫£n {location}",
                "type": "seafood",
                "estimated_price": 400_000
            })
        
        return food_suggestions
    
    def _detect_accommodation_from_preference(self, preference: str, is_last_day: bool) -> str:
        """Detect accommodation type from preference"""
        pref_lower = preference.lower()
        
        if any(kw in pref_lower for kw in ["nh√† b·∫°n", "b·∫°n b√®", "·ªü nh·ªù"]):
            return "friend"
        elif is_last_day or any(kw in pref_lower for kw in ["v·ªÅ nh√†", "v·ªÅ", "k·∫øt th√∫c"]):
            return "home"
        else:
            return "hotel"
    
    def _estimate_spot_cost(self, spot: Dict) -> int:
        """Estimate entrance cost for a spot"""
        name_lower = spot.get("name", "").lower()
        
        # Paid attractions
        if any(kw in name_lower for kw in ["vinpearl", "b√† n√†", "sun world"]):
            return 800_000
        elif any(kw in name_lower for kw in ["b·∫£o t√†ng", "museum"]):
            return 50_000
        elif any(kw in name_lower for kw in ["ch√πa", "ƒë·ªÅn", "mi·∫øu"]):
            return 0  # Free
        elif any(kw in name_lower for kw in ["bi·ªÉn", "b√£i"]):
            return 0  # Free
        else:
            return 100_000  # Default
    
    def _format_customized_itinerary(
        self,
        location: str,
        days: List[Dict],
        daily_costs: List[Dict]
    ) -> str:
        """Format customized itinerary as markdown"""
        
        total_cost = sum(d.get("cost", {}).get("total", 0) for d in days)
        
        text = f"üóìÔ∏è **L·ªãch tr√¨nh {len(days)} ng√†y t·∫°i {location}** (theo y√™u c·∫ßu c·ªßa b·∫°n)\n\n"
        
        for day in days:
            day_num = day["day"]
            preference = day.get("preference", "")
            spots = day.get("spots", [])
            cost = day.get("cost", {})
            accommodation_note = day.get("accommodation_note", "")
            
            text += f"**üìÖ Ng√†y {day_num}:** _{preference}_\n"
            
            # Morning
            if spots:
                text += f"  ‚Ä¢ 09:00 - {spots[0].get('name', 'Tham quan')}\n"
            
            text += f"  ‚Ä¢ 12:00 - ƒÇn tr∆∞a\n"
            
            # Afternoon
            if len(spots) > 1:
                text += f"  ‚Ä¢ 14:00 - {spots[1].get('name', 'Tham quan')}\n"
            elif day.get("food"):
                text += f"  ‚Ä¢ 14:00 - {day['food'][0].get('name', 'Th∆∞·ªüng th·ª©c ·∫©m th·ª±c')}\n"
            
            text += f"  ‚Ä¢ 18:00 - ƒÇn t·ªëi\n"
            
            # Accommodation
            if accommodation_note:
                text += f"  ‚Ä¢ üè® {accommodation_note}\n"
            
            # Day cost
            text += f"  üí∞ **Chi ph√≠ ng√†y {day_num}: {cost.get('total', 0):,.0f} VNƒê**\n"
            text += f"     _(L∆∞u tr√∫: {cost.get('accommodation', 0):,.0f} | "
            text += f"ƒÇn u·ªëng: {cost.get('food', 0):,.0f} | "
            text += f"Tham quan: {cost.get('activities', 0):,.0f} | "
            text += f"Di chuy·ªÉn: {cost.get('transport', 0):,.0f})_\n\n"
        
        text += f"{'‚îÄ'*40}\n"
        text += f"üíµ **T·ªîNG CHI PH√ç: {total_cost:,.0f} VNƒê**\n\n"
        text += f"üí° _B·∫°n mu·ªën thay ƒë·ªïi ƒëi·ªÉm ƒë·∫øn n√†o kh√¥ng? Ho·∫∑c t√¥i t√¨m kh√°ch s·∫°n ph√π h·ª£p cho t·ª´ng ng√†y?_"
        
        return text

    def _is_detail_request(self, message: str, context) -> bool:
        """Check if user is asking for details about something"""
        detail_keywords = [
            "chi ti·∫øt", "th√¥ng tin", "cho bi·∫øt v·ªÅ", "k·ªÉ v·ªÅ", "n√≥i v·ªÅ",
            "t√¥i quan t√¢m", "mu·ªën bi·∫øt th√™m", "bi·∫øt th√™m", "gi·ªõi thi·ªáu v·ªÅ",
            "th·∫ø n√†o", "ra sao", "nh∆∞ th·∫ø n√†o", "cho t√¥i bi·∫øt"
        ]
        message_lower = message.lower()
        return any(kw in message_lower for kw in detail_keywords)
    
    def _extract_location_and_duration_from_query(self, query: str) -> tuple:
        """
        Extract location and duration from a query string.
        
        Examples:
            "ƒêi ƒê√† N·∫µng 3 ng√†y h·∫øt bao nhi√™u?" -> ("ƒê√† N·∫µng", 3)
            "Du l·ªãch Ph√∫ Qu·ªëc 5 ng√†y chi ph√≠?" -> ("Ph√∫ Qu·ªëc", 5)
        """
        import re
        
        query_lower = query.lower()
        
        # Known locations
        locations = {
            "ƒë√† n·∫µng": "ƒê√† N·∫µng", "da nang": "ƒê√† N·∫µng",
            "h·ªôi an": "H·ªôi An", "hoi an": "H·ªôi An",
            "nha trang": "Nha Trang",
            "ph√∫ qu·ªëc": "Ph√∫ Qu·ªëc", "phu quoc": "Ph√∫ Qu·ªëc",
            "ƒë√† l·∫°t": "ƒê√† L·∫°t", "da lat": "ƒê√† L·∫°t",
            "sapa": "Sapa", "sa pa": "Sapa",
            "hu·∫ø": "Hu·∫ø", "hue": "Hu·∫ø",
            "h√† n·ªôi": "H√† N·ªôi", "ha noi": "H√† N·ªôi",
            "h·∫° long": "H·∫° Long", "ha long": "H·∫° Long",
            "ninh b√¨nh": "Ninh B√¨nh",
            "quy nh∆°n": "Quy Nh∆°n",
            "c·∫ßn th∆°": "C·∫ßn Th∆°",
            "v≈©ng t√†u": "V≈©ng T√†u",
            "b·∫øn tre": "B·∫øn Tre",
            "tp.hcm": "TP.HCM", "tp hcm": "TP.HCM", "s√†i g√≤n": "TP.HCM",
            "h√† giang": "H√† Giang",
            "cao b·∫±ng": "Cao B·∫±ng",
            "bu√¥n ma thu·ªôt": "Bu√¥n Ma Thu·ªôt",
            "pleiku": "Pleiku",
        }
        
        # Find location
        found_location = None
        for key, value in locations.items():
            if key in query_lower:
                found_location = value
                break
        
        # Extract duration (number + ng√†y/ƒë√™m)
        duration = None
        duration_match = re.search(r'(\d+)\s*(?:ng√†y|ƒë√™m)', query_lower)
        if duration_match:
            duration = int(duration_match.group(1))
        
        return found_location, duration
    
    def _is_breakdown_request(self, message: str) -> bool:
        """Check if user wants cost breakdown"""
        breakdown_keywords = [
            "m·ªói ng√†y", "t·ª´ng ng√†y", "chi ti·∫øt chi ph√≠", "ph√¢n t√≠ch",
            "chia ra", "breakdown", "c·ª• th·ªÉ t·ª´ng"
        ]
        message_lower = message.lower()
        return any(kw in message_lower for kw in breakdown_keywords)
    
    def _extract_region(self, message: str) -> Optional[str]:
        """Extract region from message"""
        regions = {
            "mi·ªÅn nam": ["Ph√∫ Qu·ªëc", "C·∫ßn Th∆°", "V≈©ng T√†u", "TP.HCM", "B·∫øn Tre", "An Giang"],
            "mi·ªÅn b·∫Øc": ["H√† N·ªôi", "Sapa", "H·∫° Long", "Ninh B√¨nh", "H√† Giang", "Cao B·∫±ng"],
            "mi·ªÅn trung": ["ƒê√† N·∫µng", "Hu·∫ø", "H·ªôi An", "Nha Trang", "Quy Nh∆°n"],
            "mi·ªÅn t√¢y": ["C·∫ßn Th∆°", "B·∫øn Tre", "An Giang", "C√† Mau"],
            "t√¢y nguy√™n": ["ƒê√† L·∫°t", "Bu√¥n Ma Thu·ªôt", "Pleiku"],
        }
        message_lower = message.lower()
        for region in regions.keys():
            if region in message_lower:
                return region
        return None
    
    def _is_recall_itinerary_request(self, message: str) -> bool:
        """Check if user wants to recall their saved itinerary"""
        message_lower = message.lower()
        recall_patterns = [
            "xem l·∫°i l·ªãch tr√¨nh",
            "l·ªãch tr√¨nh c·ªßa t√¥i",
            "l·ªãch tr√¨nh ƒë√£ t·∫°o",
            "hi·ªÉn th·ªã l·ªãch tr√¨nh",
            "show itinerary",
            "my itinerary",
            "xem l·ªãch tr√¨nh",
            "cho t√¥i xem l·ªãch tr√¨nh",
            "l·ªãch tr√¨nh h√¥m nay",
            "k·∫ø ho·∫°ch c·ªßa t√¥i"
        ]
        return any(p in message_lower for p in recall_patterns)
    
    def _handle_recall_itinerary(self, context) -> Dict[str, Any]:
        """Handle request to recall saved itinerary with FULL DATA INJECTION"""
        last_itinerary = getattr(context, 'last_itinerary', None)
        
        logger.info(f"üîç DEBUG: Recall itinerary - has last_itinerary: {last_itinerary is not None}")
        
        if not last_itinerary or not last_itinerary.get("days"):
            return {
                "reply": "üìã B·∫°n ch∆∞a t·∫°o l·ªãch tr√¨nh n√†o!\n\n"
                         "üí° H√£y th·ª≠: **\"L·∫≠p l·ªãch tr√¨nh 3 ng√†y ·ªü ƒê√† N·∫µng\"**",
                "ui_type": "text",
                "context": context.to_dict(),
                "status": "success"
            }
        
        location = last_itinerary.get("location", "")
        duration = last_itinerary.get("duration", 0)
        days_data = last_itinerary.get("days", [])
        
        logger.info(f"üìä DEBUG: Recalling itinerary - {duration} days, {len(days_data)} day records")
        
        # Build itinerary text with SPOT DETAILS
        itinerary_parts = []
        itinerary_items = []
        total_spots = 0
        spots_details = []  # NEW: Collect full spot details
        
        # Query MongoDB for spot details
        spots_collection = self.mongo_manager.get_collection("spots_detailed")
        
        for day_info in days_data:
            day_num = day_info.get("day", 0)
            spots = day_info.get("spots", [])
            total_spots += len(spots)
            
            if spots:
                spots_text = "\n".join([f"    ‚Ä¢ {s}" for s in spots])
                
                # NEW: Query MongoDB for each spot to get full details
                for spot_name in spots:
                    try:
                        # Try exact match first
                        spot_doc = spots_collection.find_one({"name": spot_name})
                        
                        # Fallback: fuzzy search
                        if not spot_doc:
                            spot_doc = spots_collection.find_one({
                                "name": {"$regex": spot_name, "$options": "i"}
                            })
                        
                        if spot_doc:
                            spots_details.append({
                                "name": spot_doc.get("name", spot_name),
                                "description": spot_doc.get("description", "ƒê·ªãa ƒëi·ªÉm du l·ªãch n·ªïi ti·∫øng"),
                                "address": spot_doc.get("address", ""),
                                "price_range": spot_doc.get("price_range", "Mi·ªÖn ph√≠"),
                                "image_url": spot_doc.get("image_url", ""),
                                "source_url": spot_doc.get("url", ""),  # Link to original article
                                "tips": spot_doc.get("tips", ""),
                                # Remove rating, add images
                                "images": spot_doc.get("images", [])
                            })
                        else:
                            # No data found, use basic info
                            spots_details.append({
                                "name": spot_name,
                                "description": "ƒê·ªãa ƒëi·ªÉm du l·ªãch n·ªïi ti·∫øng",
                                "address": "",
                                "price_range": "Mi·ªÖn ph√≠",
                                "rating": 4.5,
                                "image_url": "",
                                "tips": ""
                            })
                    except Exception as e:
                        logger.warning(f"Could not fetch details for spot: {spot_name} - {e}")
                        spots_details.append({
                            "name": spot_name,
                            "description": "ƒê·ªãa ƒëi·ªÉm du l·ªãch",
                            "address": "",
                            "price_range": "Mi·ªÖn ph√≠",
                            "rating": 4.5,
                            "image_url": "",
                            "tips": ""
                        })
            else:
                spots_text = "    ‚Ä¢ T·ª± do kh√°m ph√°"
            
            itinerary_parts.append(f"üìÖ **Ng√†y {day_num}:**\n{spots_text}")
            
            # Build UI data
            itinerary_items.append({
                "day": day_num,
                "title": f"Kh√°m ph√° {location}",
                "morning": spots[0] if len(spots) > 0 else "T·ª± do",
                "afternoon": spots[1] if len(spots) > 1 else (spots[0] if spots else "T·ª± do"),
                "evening": spots[2] if len(spots) > 2 else "Ngh·ªâ ng∆°i"
            })
        
        itinerary_text = "\n\n".join(itinerary_parts)
        
        # DATA INJECTION: Include selected hotel info
        selected_hotel = getattr(context, 'selected_hotel', None)
        selected_hotel_price = getattr(context, 'selected_hotel_price', None)
        
        hotel_info = ""
        if selected_hotel:
            hotel_info = f"\n\nüè® **Kh√°ch s·∫°n ƒë√£ ch·ªçn:** {selected_hotel}"
            if selected_hotel_price:
                hotel_info += f" - {selected_hotel_price} VNƒê/ƒë√™m"
        
        reply = f"""üóìÔ∏è **L·ªäCH TR√åNH {duration} NG√ÄY T·∫†I {location.upper()}** (ƒë√£ l∆∞u)

{itinerary_text}{hotel_info}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìä **T·ªïng quan:** {total_spots} ƒë·ªãa ƒëi·ªÉm ƒë√£ ch·ªçn

üí° **B·∫°n c√≥ th·ªÉ:**
‚Ä¢ G√µ **"t√¨m kh√°ch s·∫°n"** ƒë·ªÉ xem c√°c kh√°ch s·∫°n t·∫°i {location}
‚Ä¢ G√µ **"∆∞·ªõc t√≠nh chi ph√≠"** ƒë·ªÉ t√≠nh chi ph√≠ chuy·∫øn ƒëi
‚Ä¢ G√µ **"l·∫≠p l·ªãch l·∫°i"** ƒë·ªÉ t·∫°o l·ªãch tr√¨nh m·ªõi"""

        logger.info(f"‚úÖ DEBUG: Recall response ready - {len(reply)} chars, {len(itinerary_items)} days, {total_spots} spots")
        logger.info(f"üìç DEBUG: Collected {len(spots_details)} spot details for recall display")

        return {
            "reply": reply,
            "ui_type": "itinerary",
            "ui_data": {
                "items": itinerary_items,
                "destination": location,
                "days": duration,
                "total_days": duration,
                "spots_details": spots_details,  # NEW: Full spot information
                # DATA INJECTION: Include facts for verification
                "spots_count": total_spots,
                "has_hotel": selected_hotel is not None
            },
            "context": context.to_dict(),
            "status": "success"
        }

    async def _handle_get_detail(
        self, 
        user_message: str, 
        context, 
        multi_intent
    ) -> Optional[Dict[str, Any]]:
        """Handle request for details about a specific entity"""
        
        # Try to find what entity user is asking about
        entity_name = None
        entity_data = None
        entity_type = None
        
        # Check last shown spots
        last_spots = getattr(context, 'last_spots', [])
        last_hotels = getattr(context, 'last_hotels', [])
        
        message_lower = user_message.lower()
        
        # Check for ordinal references like "ƒë·∫ßu ti√™n", "th·ª© 2", "s·ªë 1"
        ordinal_index = self._extract_ordinal_index(message_lower)
        if ordinal_index is not None:
            # User is referring to an item by position
            if last_spots and ordinal_index < len(last_spots):
                entity_data = last_spots[ordinal_index]
                entity_name = entity_data.get("name")
                entity_type = "spot"
                logger.info(f"üìç Found by ordinal #{ordinal_index + 1}: {entity_name}")
            elif last_hotels and ordinal_index < len(last_hotels):
                entity_data = last_hotels[ordinal_index]
                entity_name = entity_data.get("name")
                entity_type = "hotel"
                logger.info(f"üè® Found by ordinal #{ordinal_index + 1}: {entity_name}")
        
        # Search in spots from context by name match
        if not entity_name:
            for spot in last_spots:
                name = spot.get("name", "").lower()
                if name and name in message_lower:
                    entity_name = spot.get("name")
                    entity_data = spot
                    entity_type = "spot"
                    break
        
        # Search in hotels if not found in spots
        if not entity_name:
            for hotel in last_hotels:
                name = hotel.get("name", "").lower()
                if name and name in message_lower:
                    entity_name = hotel.get("name")
                    entity_data = hotel
                    entity_type = "hotel"
                    break
        
        # If not found in context, search directly in database
        if not entity_name and self.mongo_manager:
            entity_data, entity_type = await self._search_entity_in_db(message_lower, multi_intent)
            if entity_data:
                entity_name = entity_data.get("name")
        
        if entity_name and entity_data:
            # Generate detailed response using LLM if available
            if self.llm and entity_type == "spot":
                detail_response = await self._generate_spot_detail(entity_name, entity_data, context)
            elif self.llm and entity_type == "hotel":
                detail_response = await self._generate_hotel_detail(entity_name, entity_data, context)
            else:
                detail_response = self._format_entity_detail(entity_name, entity_data, entity_type)
            
            return detail_response
        
        # Entity not found - provide helpful response
        location = multi_intent.location or getattr(context, 'destination', None)
        return {
            "reply": f"T√¥i ch∆∞a t√¨m th·∫•y th√¥ng tin chi ti·∫øt v·ªÅ ƒë·ªãa ƒëi·ªÉm n√†y.\n\n"
                     f"üí° B·∫°n c√≥ th·ªÉ:\n"
                     f"‚Ä¢ Ch·ªçn t·ª´ danh s√°ch ƒë·ªãa ƒëi·ªÉm ƒë√£ g·ª£i √Ω\n"
                     f"‚Ä¢ H·ªèi: 'ƒê·ªãa ƒëi·ªÉm tham quan ·ªü {location or 'X'}'\n"
                     f"‚Ä¢ Ho·∫∑c n√≥i r√µ t√™n ƒë·ªãa ƒëi·ªÉm b·∫°n quan t√¢m",
            "ui_type": "none",
            "context": context.to_dict(),
            "status": "partial"
        }
    
    def _extract_ordinal_index(self, message: str) -> Optional[int]:
        """Extract ordinal number from message (0-indexed)
        
        Examples:
            "ƒë·∫ßu ti√™n", "c√°i 1", "s·ªë 1" -> 0
            "th·ª© 2", "c√°i 2", "s·ªë 2" -> 1
            "th·ª© 3", "c√°i cu·ªëi" -> 2, last
        """
        import re
        
        # Vietnamese ordinal patterns
        ordinal_map = {
            # First
            "ƒë·∫ßu ti√™n": 0, "th·ª© nh·∫•t": 0, "c√°i 1": 0, "s·ªë 1": 0,
            "option 1": 0, "l·ª±a ch·ªçn 1": 0, "1.": 0,
            # Second
            "th·ª© 2": 1, "th·ª© hai": 1, "c√°i 2": 1, "s·ªë 2": 1,
            "option 2": 1, "l·ª±a ch·ªçn 2": 1, "2.": 1,
            # Third
            "th·ª© 3": 2, "th·ª© ba": 2, "c√°i 3": 2, "s·ªë 3": 2,
            "option 3": 2, "l·ª±a ch·ªçn 3": 2, "3.": 2,
            # Fourth
            "th·ª© 4": 3, "th·ª© t∆∞": 3, "c√°i 4": 3, "s·ªë 4": 3,
            "option 4": 3, "l·ª±a ch·ªçn 4": 3, "4.": 3,
            # Fifth
            "th·ª© 5": 4, "th·ª© nƒÉm": 4, "c√°i 5": 4, "s·ªë 5": 4,
            "option 5": 4, "l·ª±a ch·ªçn 5": 4, "5.": 4,
            # Sixth
            "th·ª© 6": 5, "th·ª© s√°u": 5, "c√°i 6": 5, "s·ªë 6": 5,
            "option 6": 5, "l·ª±a ch·ªçn 6": 5, "6.": 5,
        }
        
        message_lower = message.lower()
        
        for pattern, index in ordinal_map.items():
            if pattern in message_lower:
                return index
        
        # Try regex for "th·ª© X" pattern
        match = re.search(r'th·ª©\s*(\d+)', message_lower)
        if match:
            return int(match.group(1)) - 1  # Convert to 0-indexed
        
        # Try regex for standalone number "1", "2", etc.
        match = re.search(r'\b(\d+)\b', message_lower)
        if match:
            num = int(match.group(1))
            if 1 <= num <= 10:
                return num - 1
        
        return None
    
    
    async def _search_entity_in_db(self, message_lower: str, multi_intent) -> tuple:
        """Search for entity directly in database when not found in context
        
        Uses priority-based matching:
        1. Exact phrase match (highest priority)
        2. All terms must be present (AND)
        3. Any term match with scoring (OR + rank by match count)
        
        Returns:
            tuple: (entity_data, entity_type) or (None, None)
        """
        import re
        
        # Extract potential entity name from message
        # Remove common Vietnamese question words
        stop_words = [
            "chi ti·∫øt", "th√¥ng tin", "cho bi·∫øt", "k·ªÉ v·ªÅ", "n√≥i v·ªÅ", "gi·ªõi thi·ªáu",
            "v·ªÅ", "·ªü", "t·∫°i", "c·ªßa", "trong", "ngo√†i", "g·∫ßn", "xa",
            "cho", "t√¥i", "m√¨nh", "b·∫°n", "h√£y", "xin", "ƒë∆∞·ª£c", "kh√¥ng",
            "nh∆∞ th·∫ø n√†o", "ra sao", "th·∫ø n√†o", "g√¨", "ƒë√¢u", "bao nhi√™u",
            "mu·ªën", "bi·∫øt", "th√™m", "xem", "c√≥", "th·ªÉ"
        ]
        
        search_text = message_lower
        for word in stop_words:
            search_text = search_text.replace(word, " ")
        
        # Clean up extra spaces and get potential name
        search_terms = [t.strip() for t in search_text.split() if len(t.strip()) > 1]
        
        if not search_terms:
            return None, None
        
        # Build search phrase (for exact match)
        search_phrase = " ".join(search_terms)
        
        logger.info(f"üîç Searching DB for: '{search_phrase}' (terms: {search_terms})")
        
        # üî• FIX: Get current destination/province from context for geo-filtering
        current_province = None
        if hasattr(multi_intent, 'location') and multi_intent.location:
            current_province = multi_intent.location
            logger.info(f"üìç Geo-filter active: {current_province}")
        
        # Convert province name to slug for matching
        province_slug = None
        if current_province:
            province_slug = current_province.lower()
            province_slug = province_slug.replace("ƒë", "d").replace("ƒÉ", "a").replace("√¢", "a")
            province_slug = province_slug.replace("√™", "e").replace("√¥", "o").replace("∆°", "o")
            province_slug = province_slug.replace("∆∞", "u").replace(" ", "-")
        
        try:
            spots_col = self.mongo_manager.get_collection("spots_detailed")
            
            # Build base geo-filter if we have province context
            geo_filter = {}
            if province_slug:
                geo_filter = {"province_id": {"$regex": province_slug, "$options": "i"}}
            
            # Priority 1: Exact phrase match in name (WITH GEO-FILTER)
            query = {"name": {"$regex": search_phrase, "$options": "i"}}
            if geo_filter:
                query.update(geo_filter)
            
            spot = spots_col.find_one(query)
            if spot:
                spot = _clean_mongo_doc(spot)
                logger.info(f"‚úÖ Found exact match: {spot.get('name')}")
                return spot, "spot"
            
            # Priority 2: Try combining key terms (e.g., "b√£i sao" together)
            if len(search_terms) >= 2:
                # Try pairs of consecutive terms
                for i in range(len(search_terms) - 1):
                    pair = f"{search_terms[i]} {search_terms[i+1]}"
                    query = {"name": {"$regex": pair, "$options": "i"}}
                    if geo_filter:
                        query.update(geo_filter)
                    
                    spot = spots_col.find_one(query)
                    if spot:
                        spot = _clean_mongo_doc(spot)
                        logger.info(f"‚úÖ Found pair match '{pair}': {spot.get('name')}")
                        return spot, "spot"
            
            # Priority 3: All significant terms must be present (AND logic)
            # Filter out very short or common words
            significant_terms = [t for t in search_terms if len(t) >= 3]
            if len(significant_terms) >= 2:
                and_conditions = [
                    {"name": {"$regex": term, "$options": "i"}}
                    for term in significant_terms
                ]
                query = {"$and": and_conditions}
                if geo_filter:
                    and_conditions.append(geo_filter)
                    query = {"$and": and_conditions}
                
                spot = spots_col.find_one(query)
                if spot:
                    spot = _clean_mongo_doc(spot)
                    logger.info(f"‚úÖ Found AND match: {spot.get('name')}")
                    return spot, "spot"
            
            # Priority 4: Score-based OR search (count matching terms)
            or_conditions = [
                {"name": {"$regex": term, "$options": "i"}}
                for term in search_terms if len(term) >= 3
            ]
            
            if or_conditions:
                # Get all candidates (with geo-filter if available)
                query = {"$or": or_conditions}
                if geo_filter:
                    query = {"$and": [geo_filter, {"$or": or_conditions}]}
                
                candidates = list(spots_col.find(query).limit(20))
                
                if candidates:
                    # Score each candidate by how many terms match
                    def score_candidate(doc):
                        name_lower = doc.get("name", "").lower()
                        score = 0
                        for term in search_terms:
                            if term in name_lower:
                                score += len(term)  # Longer term matches worth more
                        return score
                    
                    # Sort by score (highest first)
                    candidates.sort(key=score_candidate, reverse=True)
                    best = _clean_mongo_doc(candidates[0])
                    logger.info(f"‚úÖ Found scored match: {best.get('name')} (score: {score_candidate(candidates[0])})")
                    return best, "spot"
            
            # Try hotels collection with same logic (WITH GEO-FILTER)
            hotels_col = self.mongo_manager.get_collection("hotels")
            if hotels_col is not None:
                # Exact match first
                query = {"name": {"$regex": search_phrase, "$options": "i"}}
                if geo_filter:
                    query.update(geo_filter)
                
                hotel = hotels_col.find_one(query)
                if hotel:
                    hotel = _clean_mongo_doc(hotel)
                    logger.info(f"‚úÖ Found hotel: {hotel.get('name')}")
                    return hotel, "hotel"
            
        except Exception as e:
            logger.error(f"‚ùå Database search error: {e}")
        
        logger.info(f"‚ùå No match found for: {search_phrase}")
        return None, None
    
    async def _generate_spot_detail(self, name: str, data: Dict, context) -> Dict:
        """Generate detailed spot info using LLM"""
        prompt = f"""B·∫°n l√† h∆∞·ªõng d·∫´n vi√™n du l·ªãch. Gi·ªõi thi·ªáu v·ªÅ: {name}

D·ªØ li·ªáu c√≥ s·∫µn:
- ƒê√°nh gi√°: {data.get('rating', 'N/A')} sao ({data.get('reviews_count', 0)} ƒë√°nh gi√°)
- ƒê·ªãa ch·ªâ: {data.get('address', 'N/A')}
- M√¥ t·∫£: {data.get('description_short', 'Ch∆∞a c√≥ m√¥ t·∫£')}
- Danh m·ª•c: {data.get('category', 'N/A')}

Vi·∫øt gi·ªõi thi·ªáu h·∫•p d·∫´n 3-5 c√¢u, bao g·ªìm:
1. ƒêi·ªÉm ƒë·∫∑c bi·ªát
2. Th·ªùi gian tham quan l√Ω t∆∞·ªüng
3. Tips khi ƒë·∫øn
"""
        try:
            response = self.llm.chat([{"role": "user", "content": prompt}])
            reply = f"üìç **{name}**\n\n{response}\n\n"
            reply += f"‚≠ê ƒê√°nh gi√°: {data.get('rating', 'N/A')}/5 ({data.get('reviews_count', 0)} reviews)\n"
            reply += f"üìÆ ƒê·ªãa ch·ªâ: {data.get('address', 'ƒêang c·∫≠p nh·∫≠t')}"
        except:
            reply = self._format_entity_detail(name, data, "spot")["reply"]
        
        return {
            "reply": reply,
            "ui_type": "spot_detail",
            "ui_data": {"spot": data},
            "context": context.to_dict(),
            "status": "partial"
        }
    
    async def _generate_hotel_detail(self, name: str, data: Dict, context) -> Dict:
        """Generate detailed hotel info using LLM"""
        prompt = f"""B·∫°n l√† chuy√™n gia ƒë√°nh gi√° kh√°ch s·∫°n. Gi·ªõi thi·ªáu v·ªÅ: {name}

D·ªØ li·ªáu:
- ƒê√°nh gi√°: {data.get('rating', 'N/A')} sao
- Gi√°: {data.get('price', 'N/A')} VNƒê/ƒë√™m
- ƒê·ªãa ch·ªâ: {data.get('address', 'N/A')}

Vi·∫øt ƒë√°nh gi√° ng·∫Øn g·ªçn 2-3 c√¢u v·ªÅ ∆∞u ƒëi·ªÉm kh√°ch s·∫°n.
"""
        try:
            response = self.llm.chat([{"role": "user", "content": prompt}])
            reply = f"üè® **{name}**\n\n{response}\n\n"
            reply += f"‚≠ê ƒê√°nh gi√°: {data.get('rating', 'N/A')}/5\n"
            reply += f"üí∞ Gi√°: {data.get('price', 0):,} VNƒê/ƒë√™m\n"
            reply += f"üìç {data.get('address', 'ƒêang c·∫≠p nh·∫≠t')}"
        except:
            reply = self._format_entity_detail(name, data, "hotel")["reply"]
        
        return {
            "reply": reply,
            "ui_type": "hotel_detail",
            "ui_data": {"hotel": data},
            "context": context.to_dict(),
            "status": "partial"
        }
    
    def _format_entity_detail(self, name: str, data: Dict, entity_type: str) -> Dict:
        """Format entity detail without LLM"""
        if entity_type == "spot":
            reply = f"üìç **{name}**\n\n"
            reply += f"{data.get('description_short', 'M·ªôt ƒë·ªãa ƒëi·ªÉm du l·ªãch h·∫•p d·∫´n.')}\n\n"
            reply += f"‚≠ê ƒê√°nh gi√°: {data.get('rating', 'N/A')}/5\n"
            reply += f"üìÆ ƒê·ªãa ch·ªâ: {data.get('address', 'ƒêang c·∫≠p nh·∫≠t')}"
            ui_type = "spot_detail"
        else:
            reply = f"üè® **{name}**\n\n"
            reply += f"‚≠ê ƒê√°nh gi√°: {data.get('rating', 'N/A')}/5\n"
            reply += f"üí∞ Gi√°: {data.get('price', 0):,} VNƒê/ƒë√™m\n"
            reply += f"üìç {data.get('address', 'ƒêang c·∫≠p nh·∫≠t')}"
            ui_type = "hotel_detail"
        
        return {"reply": reply, "ui_type": ui_type, "ui_data": {entity_type: data}}
    
    async def _handle_breakdown(self, context, multi_intent) -> Dict:
        """Handle cost breakdown by day request"""
        location = multi_intent.location or getattr(context, 'destination', None) or "ƒëi·ªÉm ƒë·∫øn"
        duration = multi_intent.duration or getattr(context, 'duration', None) or 3
        people_count = multi_intent.people_count or getattr(context, 'people_count', 1)
        
        # Get last cost if available
        last_cost = getattr(context, 'last_cost', None)
        
        if last_cost:
            total = last_cost.get('total', 4500000)
            daily = total / duration
        else:
            daily = 1500000  # Default per day
            total = daily * duration
        
        # Create breakdown
        breakdown = f"üìä **Chi ph√≠ chi ti·∫øt t·ª´ng ng√†y t·∫°i {location}**\n\n"
        
        for day in range(1, duration + 1):
            breakdown += f"**üìÖ Ng√†y {day}:**\n"
            breakdown += f"  üè® Kh√°ch s·∫°n: {500000:,} VNƒê\n"
            breakdown += f"  üçú ƒÇn s√°ng: {50000:,} VNƒê\n"
            breakdown += f"  üçú ƒÇn tr∆∞a: {100000:,} VNƒê\n"
            breakdown += f"  üçú ƒÇn t·ªëi: {150000:,} VNƒê\n"
            breakdown += f"  üöï Di chuy·ªÉn: {200000:,} VNƒê\n"
            breakdown += f"  üé´ Tham quan: {500000:,} VNƒê\n"
            breakdown += f"  **T·ªïng ng√†y {day}: {1500000:,} VNƒê**\n\n"
        
        breakdown += f"üíµ **T·ªîNG C·ªòNG {duration} NG√ÄY: {total:,} VNƒê**\n"
        if people_count > 1:
            breakdown += f"üë• Cho {people_count} ng∆∞·ªùi: {total * people_count:,} VNƒê\n"
        
        breakdown += f"\nüí° _M·∫πo ti·∫øt ki·ªám: ƒê·∫∑t ph√≤ng tr∆∞·ªõc 2 tu·∫ßn ƒë·ªÉ c√≥ gi√° t·ªët h∆°n!_"
        
        return {
            "reply": breakdown,
            "ui_type": "cost_breakdown",
            "ui_data": {"breakdown": {"daily": daily, "total": total, "duration": duration}},
            "context": context.to_dict(),
            "status": "partial"
        }
    
    async def _handle_region_search(self, region: str, context) -> Dict:
        """Handle search by region (mi·ªÅn nam, mi·ªÅn b·∫Øc, etc.)"""
        regions = {
            "mi·ªÅn nam": {
                "provinces": ["Ph√∫ Qu·ªëc", "C·∫ßn Th∆°", "V≈©ng T√†u", "TP.HCM", "B·∫øn Tre", "An Giang"],
                "description": "V√πng ƒë·∫•t ph∆∞∆°ng Nam tr√π ph√∫ v·ªõi s√¥ng n∆∞·ªõc, mi·ªát v∆∞·ªùn v√† bi·ªÉn ƒë·∫£o xinh ƒë·∫πp",
                "highlights": "üèùÔ∏è Bi·ªÉn ƒë·∫£o, üå¥ Mi·ªát v∆∞·ªùn, üç≤ ·∫®m th·ª±c phong ph√∫"
            },
            "mi·ªÅn b·∫Øc": {
                "provinces": ["H√† N·ªôi", "Sapa", "H·∫° Long", "Ninh B√¨nh", "H√† Giang", "Cao B·∫±ng"],
                "description": "V√πng ƒë·∫•t ng√†n nƒÉm vƒÉn hi·∫øn v·ªõi n√∫i non h√πng vƒ© v√† vƒÉn h√≥a ƒë·∫≠m ƒë√† b·∫£n s·∫Øc",
                "highlights": "‚õ∞Ô∏è N√∫i non, üèõÔ∏è Di s·∫£n, üçú ·∫®m th·ª±c B·∫Øc"
            },
            "mi·ªÅn trung": {
                "provinces": ["ƒê√† N·∫µng", "Hu·∫ø", "H·ªôi An", "Nha Trang", "Quy Nh∆°n"],
                "description": "D·∫£i ƒë·∫•t mi·ªÅn Trung v·ªõi bi·ªÉn xanh, c·ªë ƒë√¥ v√† di s·∫£n vƒÉn h√≥a th·∫ø gi·ªõi",
                "highlights": "üèñÔ∏è Bi·ªÉn ƒë·∫πp, üèõÔ∏è C·ªë ƒë√¥, üèÆ Ph·ªë c·ªï"
            },
            "mi·ªÅn t√¢y": {
                "provinces": ["C·∫ßn Th∆°", "B·∫øn Tre", "An Giang", "C√† Mau"],
                "description": "V√πng s√¥ng n∆∞·ªõc C·ª≠u Long v·ªõi ch·ª£ n·ªïi, v∆∞·ªùn tr√°i c√¢y v√† cu·ªôc s·ªëng b√¨nh d·ªã",
                "highlights": "üõ∂ Ch·ª£ n·ªïi, ü•≠ Mi·ªát v∆∞·ªùn, üè° L√†ng qu√™"
            },
            "t√¢y nguy√™n": {
                "provinces": ["ƒê√† L·∫°t", "Bu√¥n Ma Thu·ªôt", "Pleiku"],
                "description": "Cao nguy√™n m√°t m·∫ª v·ªõi hoa, c√† ph√™ v√† vƒÉn h√≥a d√¢n t·ªôc ƒë·ªôc ƒë√°o",
                "highlights": "üå∏ Hoa, ‚òï C√† ph√™, üé≠ VƒÉn h√≥a d√¢n t·ªôc"
            }
        }
        
        region_data = regions.get(region, regions["mi·ªÅn nam"])
        provinces = region_data["provinces"]
        
        reply = f"üó∫Ô∏è **Du l·ªãch {region.title()}**\n\n"
        reply += f"{region_data['description']}\n\n"
        reply += f"‚ú® **ƒêi·ªÉm n·ªïi b·∫≠t:** {region_data['highlights']}\n\n"
        reply += f"üìç **C√°c ƒëi·ªÉm ƒë·∫øn n·ªïi b·∫≠t:**\n"
        
        options = []
        for province in provinces:
            reply += f"‚Ä¢ {province}\n"
            options.append({
                "label": province,
                "value": province,
                "icon": "üìç"
            })
        
        reply += f"\nüëá Ch·ªçn ƒëi·ªÉm ƒë·∫øn b√™n d∆∞·ªõi ho·∫∑c g√µ t√™n n∆°i b·∫°n mu·ªën ƒëi!"
        
        return {
            "reply": reply,
            "ui_type": "options",
            "ui_data": {
                "options": options,
                "actions": [{"label": p, "value": p} for p in provinces[:5]]
            },
            "context": context.to_dict(),
            "status": "partial"
        }
    
    async def _handle_cost_from_context(
        self, 
        context, 
        multi_intent,
        user_message: str = ""
    ) -> Optional[Dict[str, Any]]:
        """
        Calculate cost from conversation context with SMART per-day breakdown.
        
        Handles special cases:
        - ·ªû nh√† b·∫°n b√® / v·ªÅ nh√† ‚Üí No accommodation cost
        - ƒê·ªãa ƒëi·ªÉm mi·ªÖn ph√≠ (ch√πa, c√¥ng vi√™n) ‚Üí Reduced activity cost
        - Ng√†y cu·ªëi v·ªÅ nh√† ‚Üí No accommodation
        """
        
        location = multi_intent.location or getattr(context, 'destination', None)
        duration = multi_intent.duration or getattr(context, 'duration', None)
        
        # Fallback: Try to extract location from user message if not found
        if not location or not duration:
            extracted_location, extracted_duration = self._extract_location_and_duration_from_query(user_message)
            if not location:
                location = extracted_location
            if not duration:
                duration = extracted_duration
        
        # Default duration if still not found
        if not duration:
            duration = 3
        
        if not location:
            return {
                "reply": "B·∫°n mu·ªën t√≠nh chi ph√≠ cho chuy·∫øn ƒëi ƒë·∫øn ƒë√¢u? üó∫Ô∏è\n"
                         "H√£y cho t√¥i bi·∫øt ƒëi·ªÉm ƒë·∫øn v√† s·ªë ng√†y ƒë·ªÉ t√¥i ∆∞·ªõc t√≠nh!",
                "ui_type": "cost_prompt",
                "context": context.to_dict(),
                "status": "partial"
            }
        
        # Update context with extracted values
        if location:
            context.destination = location
        if duration:
            context.duration = duration
        
        # Get itinerary if available for smart calculation
        last_itinerary = getattr(context, 'last_itinerary', None)
        
        # Calculate per-day costs
        daily_costs = await self._calculate_smart_daily_costs(
            location=location,
            duration=duration,
            context=context,
            itinerary=last_itinerary
        )
        
        # Generate detailed response
        cost_text = self._format_smart_cost_response(location, daily_costs)
        
        return {
            "reply": cost_text,
            "ui_type": "cost_breakdown",
            "ui_data": {
                "daily_costs": daily_costs,
                "location": location,
                "duration": len(daily_costs)
            },
            "context": context.to_dict(),
            "status": "partial"
        }
    
    async def _calculate_smart_daily_costs(
        self,
        location: str,
        duration: int,
        context,
        itinerary: Optional[Dict] = None
    ) -> List[Dict]:
        """
        Calculate costs per day with smart logic.
        
        Considers:
        - Accommodation type (hotel, friend's house, home)
        - Activity types (paid attractions, free spots)
        - Transportation needs
        - Meal arrangements
        """
        daily_costs = []
        
        # Default prices (can be customized per location)
        default_prices = self._get_location_default_prices(location)
        
        # Get selected hotel price if available (priority: selected_hotel_price > default)
        selected_hotel = getattr(context, 'selected_hotel', None)
        selected_hotel_price = getattr(context, 'selected_hotel_price', None)
        hotel_price = selected_hotel_price if selected_hotel_price else default_prices['hotel']
        
        if selected_hotel and selected_hotel_price:
            logger.info(f"üí∞ Using selected hotel price: {selected_hotel} - {selected_hotel_price:,} VNƒê/ƒë√™m")
        
        for day_num in range(1, duration + 1):
            day_cost = {
                "day": day_num,
                "accommodation": {"cost": 0, "note": ""},
                "activities": {"cost": 0, "items": []},
                "food": {"cost": 0, "note": ""},
                "transport": {"cost": 0, "note": ""},
                "total": 0
            }
            
            # Get day's activities from itinerary if available
            day_activities = self._get_day_activities(itinerary, day_num) if itinerary else []
            
            # === ACCOMMODATION ===
            is_last_day = (day_num == duration)
            accommodation_type = self._detect_accommodation_type(day_activities, is_last_day)
            
            if accommodation_type == "hotel":
                day_cost["accommodation"]["cost"] = hotel_price
                day_cost["accommodation"]["note"] = "Kh√°ch s·∫°n"
            elif accommodation_type == "friend":
                day_cost["accommodation"]["cost"] = 0
                day_cost["accommodation"]["note"] = "·ªû nh√† b·∫°n b√®"
            elif accommodation_type == "home":
                day_cost["accommodation"]["cost"] = 0
                day_cost["accommodation"]["note"] = "V·ªÅ nh√†"
            else:
                # Default for non-last day
                day_cost["accommodation"]["cost"] = hotel_price
                day_cost["accommodation"]["note"] = "Kh√°ch s·∫°n"
            
            # === ACTIVITIES ===
            activity_cost, activity_items = self._calculate_activity_costs(
                day_activities, default_prices
            )
            day_cost["activities"]["cost"] = activity_cost
            day_cost["activities"]["items"] = activity_items
            
            # === FOOD ===
            food_cost, food_note = self._calculate_food_costs(
                day_activities, default_prices
            )
            day_cost["food"]["cost"] = food_cost
            day_cost["food"]["note"] = food_note
            
            # === TRANSPORT ===
            transport_cost = self._calculate_transport_costs(
                day_num, duration, day_activities, default_prices
            )
            day_cost["transport"]["cost"] = transport_cost
            day_cost["transport"]["note"] = "Di chuy·ªÉn n·ªôi th√†nh" if day_num not in [1, duration] else "Di chuy·ªÉn"
            
            # Calculate day total
            day_cost["total"] = (
                day_cost["accommodation"]["cost"] +
                day_cost["activities"]["cost"] +
                day_cost["food"]["cost"] +
                day_cost["transport"]["cost"]
            )
            
            daily_costs.append(day_cost)
        
        return daily_costs
    
    def _get_location_default_prices(self, location: str) -> Dict:
        """Get default prices based on location tier"""
        location_lower = location.lower()
        
        # Tier 1: Major tourist destinations (higher prices)
        tier1 = ["ƒë√† n·∫µng", "nha trang", "ph√∫ qu·ªëc", "sapa", "ƒë√† l·∫°t"]
        # Tier 2: Medium cities
        tier2 = ["h·ªôi an", "hu·∫ø", "h·∫° long", "ninh b√¨nh", "quy nh∆°n"]
        
        if any(loc in location_lower for loc in tier1):
            return {
                "hotel": 600_000,      # 600k/ƒë√™m
                "food": 350_000,       # 350k/ng√†y  
                "transport": 250_000,  # 250k/ng√†y
                "activity": 200_000    # 200k trung b√¨nh m·ªói ƒëi·ªÉm
            }
        elif any(loc in location_lower for loc in tier2):
            return {
                "hotel": 450_000,
                "food": 280_000,
                "transport": 180_000,
                "activity": 150_000
            }
        else:
            # Default pricing
            return {
                "hotel": 400_000,
                "food": 250_000,
                "transport": 150_000,
                "activity": 100_000
            }
    
    def _get_day_activities(self, itinerary: Dict, day_num: int) -> List[str]:
        """Extract activities for a specific day from itinerary"""
        if not itinerary:
            return []
        
        days = itinerary.get("days", [])
        if day_num <= len(days):
            day_data = days[day_num - 1]
            if isinstance(day_data, dict):
                return day_data.get("activities", [])
            elif isinstance(day_data, list):
                return day_data
        return []
    
    def _detect_accommodation_type(self, activities: List, is_last_day: bool) -> str:
        """Detect accommodation type from activities"""
        activities_text = " ".join(str(a).lower() for a in activities)
        
        # Check for friend's house
        friend_keywords = ["nh√† b·∫°n", "b·∫°n b√®", "nh√† ng∆∞·ªùi th√¢n", "nh√† h·ªç h√†ng", "·ªü nh·ªù"]
        if any(kw in activities_text for kw in friend_keywords):
            return "friend"
        
        # Check for going home
        home_keywords = ["v·ªÅ nh√†", "tr·ªü v·ªÅ", "quay v·ªÅ", "k·∫øt th√∫c"]
        if is_last_day or any(kw in activities_text for kw in home_keywords):
            return "home"
        
        return "hotel"
    
    def _calculate_activity_costs(
        self, 
        activities: List, 
        default_prices: Dict
    ) -> tuple:
        """Calculate activity costs with smart detection"""
        
        # Free activities
        free_keywords = ["ch√πa", "ƒë·ªÅn", "mi·∫øu", "c√¥ng vi√™n", "b√£i bi·ªÉn", 
                        "ph·ªë c·ªï", "ch·ª£", "ng·∫Øm", "d·∫°o", "ch·ª•p ·∫£nh", 
                        "thi√™n nhi√™n", "ho√†ng h√¥n", "b√¨nh minh"]
        
        # Paid attractions (with approximate prices)
        paid_attractions = {
            "vinpearl": 800_000,
            "b√† n√†": 900_000,
            "sun world": 700_000,
            "safari": 600_000,
            "aquarium": 200_000,
            "b·∫£o t√†ng": 50_000,
            "fansipan": 750_000,
            "cable car": 400_000,
            "c√°p treo": 400_000,
            "v√© tham quan": 100_000
        }
        
        total_cost = 0
        items = []
        
        activities_text = " ".join(str(a).lower() for a in activities)
        
        # Check for paid attractions
        for attraction, price in paid_attractions.items():
            if attraction in activities_text:
                total_cost += price
                items.append({"name": attraction.title(), "cost": price})
        
        # If no specific paid attractions found, estimate based on activity count
        if not items and activities:
            # Check if mostly free activities
            is_mostly_free = any(kw in activities_text for kw in free_keywords)
            if is_mostly_free:
                total_cost = 50_000  # Small incidentals
                items.append({"name": "Tham quan mi·ªÖn ph√≠", "cost": 50_000})
            else:
                # Default activity cost
                total_cost = default_prices['activity'] * min(2, len(activities))
                items.append({"name": "Tham quan", "cost": total_cost})
        
        return total_cost, items
    
    def _calculate_food_costs(
        self, 
        activities: List, 
        default_prices: Dict
    ) -> tuple:
        """Calculate food costs"""
        activities_text = " ".join(str(a).lower() for a in activities)
        
        # Check for self-cooking or friend's house
        if any(kw in activities_text for kw in ["t·ª± n·∫•u", "nh√† b·∫°n", "·ªü nh√†"]):
            return 100_000, "N·∫•u ƒÉn t·∫°i ch·ªó"
        
        # Check for street food
        if any(kw in activities_text for kw in ["ƒÉn v·∫∑t", "ch·ª£", "qu√°n nh·ªè"]):
            return default_prices['food'] * 0.7, "ƒÇn b√¨nh d√¢n"
        
        # Default
        return default_prices['food'], "ƒÇn u·ªëng"
    
    def _calculate_transport_costs(
        self, 
        day_num: int, 
        duration: int, 
        activities: List,
        default_prices: Dict
    ) -> int:
        """Calculate transport costs"""
        
        # First day may have airport/bus transfer
        if day_num == 1:
            return default_prices['transport'] * 1.5
        
        # Last day - return trip
        if day_num == duration:
            return default_prices['transport'] * 1.5
        
        # Middle days - local transport
        return default_prices['transport']
    
    def _format_smart_cost_response(
        self, 
        location: str, 
        daily_costs: List[Dict]
    ) -> str:
        """Format smart cost breakdown as markdown"""
        
        total_all = sum(d["total"] for d in daily_costs)
        duration = len(daily_costs)
        
        text = f"ÔøΩ **Chi ph√≠ chi ti·∫øt {duration} ng√†y t·∫°i {location}:**\n\n"
        
        # Summary totals
        total_accommodation = sum(d["accommodation"]["cost"] for d in daily_costs)
        total_activities = sum(d["activities"]["cost"] for d in daily_costs)
        total_food = sum(d["food"]["cost"] for d in daily_costs)
        total_transport = sum(d["transport"]["cost"] for d in daily_costs)
        
        text += "üìä **T·ªïng quan:**\n"
        text += f"üè® L∆∞u tr√∫: **{total_accommodation:,.0f}** VNƒê\n"
        text += f"üé´ Tham quan: **{total_activities:,.0f}** VNƒê\n"
        text += f"üçú ƒÇn u·ªëng: **{total_food:,.0f}** VNƒê\n"
        text += f"üöï Di chuy·ªÉn: **{total_transport:,.0f}** VNƒê\n"
        text += f"\n**üíµ T·ªîNG C·ªòNG: {total_all:,.0f} VNƒê**\n"
        
        # Per-day breakdown
        text += f"\n{'‚îÄ'*30}\n"
        text += "üìÖ **Chi ti·∫øt t·ª´ng ng√†y:**\n\n"
        
        for day in daily_costs:
            day_num = day["day"]
            text += f"**Ng√†y {day_num}:** {day['total']:,.0f} VNƒê\n"
            
            if day["accommodation"]["cost"] > 0:
                text += f"  ‚Ä¢ L∆∞u tr√∫: {day['accommodation']['cost']:,.0f} ({day['accommodation']['note']})\n"
            elif day["accommodation"]["note"]:
                text += f"  ‚Ä¢ L∆∞u tr√∫: 0 ({day['accommodation']['note']})\n"
            
            if day["activities"]["cost"] > 0:
                items_str = ", ".join(i["name"] for i in day["activities"]["items"])
                text += f"  ‚Ä¢ Tham quan: {day['activities']['cost']:,.0f} ({items_str})\n"
            
            text += f"  ‚Ä¢ ƒÇn u·ªëng: {day['food']['cost']:,.0f}\n"
            text += f"  ‚Ä¢ Di chuy·ªÉn: {day['transport']['cost']:,.0f}\n"
            text += "\n"
        
        text += "_* Chi ph√≠ ∆∞·ªõc t√≠nh, c√≥ th·ªÉ thay ƒë·ªïi theo l·ª±a ch·ªçn th·ª±c t·∫ø._"
        
        return text
    
    async def _create_smart_fallback(
        self, 
        user_message: str, 
        multi_intent, 
        context
    ) -> Dict[str, Any]:
        """Create a smart fallback response when no tasks are created"""
        
        location = multi_intent.location or getattr(context, 'destination', None)
        
        if location:
            # Update context with location
            context.destination = location
            # We have location but no tasks - prompt for more details with GenUI options
            return {
                "reply": f"üåü **{location}** - th√†nh ph·ªë bi·ªÉn xinh ƒë·∫πp!\n\n"
                         f"üìç ƒêi·ªÉm n·ªïi b·∫≠t: B√£i bi·ªÉn M·ªπ Kh√™, B√† N√† Hills, C·∫ßu R·ªìng ‚ú® Ph√π h·ª£p cho: bi·ªÉn, ngh·ªâ d∆∞·ª°ng, ·∫©m th·ª±c\n\n"
                         f"ƒê·ªÉ t√¥i l√™n k·∫ø ho·∫°ch t·ªët nh·∫•t cho b·∫°n, cho t√¥i bi·∫øt th√™m:\n"
                         f"1Ô∏è‚É£ **B·∫°n ƒëi m·∫•y ng√†y?** (VD: 3 ng√†y 2 ƒë√™m) "
                         f"2Ô∏è‚É£ **ƒêi m·∫•y ng∆∞·ªùi?** "
                         f"3Ô∏è‚É£ **Ng√¢n s√°ch kho·∫£ng bao nhi√™u?** (VD: 5 tri·ªáu/ng∆∞·ªùi) "
                         f"4Ô∏è‚É£ **B·∫°n th√≠ch g√¨?** (bi·ªÉn, n√∫i, ·∫©m th·ª±c, vƒÉn h√≥a...)\n\n"
                         f"üí° Ho·∫∑c n√≥i: \"L√™n l·ªãch tr√¨nh {location} 3 ng√†y 5 tri·ªáu\"",
                "ui_type": "options",
                "ui_data": {
                    "title": "Ch·ªçn nhanh s·ªë ng√†y",
                    "options": [
                        f"L√™n l·ªãch tr√¨nh {location} 2 ng√†y",
                        f"L√™n l·ªãch tr√¨nh {location} 3 ng√†y",
                        f"L√™n l·ªãch tr√¨nh {location} 5 ng√†y",
                        f"T√¨m kh√°ch s·∫°n {location}",
                        f"ƒê·ªãa ƒëi·ªÉm tham quan {location}"
                    ]
                },
                "context": context.to_dict(),
                "status": "partial"
            }
        
        # No location, no specific request - guide user with GenUI
        return {
            "reply": "Xin ch√†o! T√¥i l√† **Saola Travel AI** ÔøΩ\n\n"
                     "T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n"
                     "üó∫Ô∏è L√™n l·ªãch tr√¨nh du l·ªãch\n"
                     "üè® T√¨m kh√°ch s·∫°n ph√π h·ª£p\n"
                     "üìç G·ª£i √Ω ƒë·ªãa ƒëi·ªÉm tham quan\n"
                     "üçú ƒê·ªÅ xu·∫•t qu√°n ƒÉn ngon\n\n"
                     "**B·∫°n mu·ªën ƒëi ƒë√¢u?**",
            "ui_type": "options",
            "ui_data": {
                "title": "ƒê·ªãa ƒëi·ªÉm ph·ªï bi·∫øn",
                "options": [
                    "Du l·ªãch ƒê√† N·∫µng",
                    "Du l·ªãch H·ªôi An", 
                    "Du l·ªãch Nha Trang",
                    "Du l·ªãch Ph√∫ Qu·ªëc",
                    "Du l·ªãch Sapa"
                ]
            },
            "context": context.to_dict(),
            "status": "partial"
        }
    
    async def _check_info_gathering_needed(
        self,
        multi_intent,
        context,
        user_message: str
    ) -> Optional[Dict[str, Any]]:
        """
        Check if we need to gather more information before planning.
        
        SMART CONVERSATION FLOW:
        - If user just mentions location without details ‚Üí Ask questions
        - If user provides location + duration/budget ‚Üí Proceed with planning
        - If user asks specific questions (hotels, spots) ‚Üí Answer directly
        
        Returns response dict if info gathering needed, None to proceed with planning
        """
        location = multi_intent.location
        duration = multi_intent.duration
        intent = multi_intent.primary_intent
        
        # If user is asking for specific info (hotels, spots, food) ‚Üí Don't block
        specific_intents = ["find_hotel", "find_spot", "find_food", "calculate_cost", "more_spots", "more_hotels", "more_food"]
        if intent in specific_intents:
            return None  # Proceed with normal flow
        
        # Check if user is directly asking about places/spots - bypass info gathering
        query_lower = user_message.lower()
        direct_spot_patterns = [
            "ƒë·ªãa ƒëi·ªÉm", "dia diem",
            "ch·ªó n√†o", "cho nao",
            "ƒëi ƒë√¢u", "di dau",
            "thƒÉm quan", "tham quan",
            "tham quan",
            "ƒëi·ªÉm ƒë·∫øn", "diem den",
            "n∆°i n√†o", "noi nao",
            "ch·ªó ch∆°i", "cho choi",
            "ƒëi ch∆°i ·ªü ƒë√¢u",
            "c√≥ g√¨", "co gi"
        ]
        if any(p in query_lower for p in direct_spot_patterns):
            return None  # User asking about spots directly, proceed
        
        # If user wants full trip planning with enough info ‚Üí START INTERACTIVE BUILDER
        if intent == "plan_trip" and location and duration:
            logger.info(f"üóìÔ∏è [ASYNC] Triggering interactive itinerary builder for {location}, {duration} days")
            # Start interactive itinerary builder
            builder_response = self._start_interactive_itinerary_sync(location, duration, context)
            if builder_response:
                return builder_response
            # If builder failed, proceed with normal flow
            return None
        
        # If user just mentions wanting to go somewhere without details
        # Check if query is simple location mention
        simple_location_patterns = [
            "mu·ªën ƒëi", "muon di",  # With and without accent
            "ƒëi ƒë·∫øn", "di den",
            "ƒë·∫øn", "den",
            "thƒÉm", "tham",
            "du l·ªãch", "du lich",
            "ƒëi ch∆°i", "di choi",
            "t·ªõi", "toi",
            "qua"  # "qua ƒê√† N·∫µng"
        ]
        
        is_simple_location_query = (
            location and 
            not duration and
            any(pattern in query_lower for pattern in simple_location_patterns) and
            intent not in specific_intents
        )
        
        if is_simple_location_query:
            # User just said "I want to go to X" - Ask for more details
            return await self._create_location_intro_response(location, context)
        
        # === NEW: Handle when user wants to travel but NO location specified ===
        # e.g., "T√¥i mu·ªën ƒëi du l·ªãch", "L√™n k·∫ø ho·∫°ch du l·ªãch", "T∆∞ v·∫•n du l·ªãch"
        no_location_travel_patterns = [
            "mu·ªën ƒëi du l·ªãch", "muon di du lich",
            "ƒëi du l·ªãch", "di du lich",
            "l√™n k·∫ø ho·∫°ch", "len ke hoach",
            "t∆∞ v·∫•n du l·ªãch", "tu van du lich", 
            "l·∫≠p k·∫ø ho·∫°ch", "lap ke hoach",
            "gi√∫p t√¥i l√™n l·ªãch", "giup toi len lich",
            "k·∫ø ho·∫°ch du l·ªãch", "ke hoach du lich",
            "chuy·∫øn ƒëi", "chuyen di",
            "mu·ªën ƒëi ch∆°i", "muon di choi"
        ]
        
        is_general_travel_query = (
            not location and
            not context.destination and
            any(pattern in query_lower for pattern in no_location_travel_patterns)
        )
        
        if is_general_travel_query:
            # User wants to travel but hasn't said where ‚Üí Show province options
            return await self._create_destination_selection_response(context)
        
        # Default: proceed with normal flow
        return None
    
    async def _create_destination_selection_response(
        self,
        context
    ) -> Dict[str, Any]:
        """Create response asking user to select destination"""
        
        response = "üåü **Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi Travel Assistant!**\n\n"
        response += "Vi·ªát Nam c√≥ r·∫•t nhi·ªÅu ƒëi·ªÉm ƒë·∫øn tuy·ªát v·ªùi. B·∫°n mu·ªën kh√°m ph√° v√πng n√†o?\n\n"
        response += "üèñÔ∏è **Bi·ªÉn ƒë·∫£o**: ƒê√† N·∫µng, Nha Trang, Ph√∫ Qu·ªëc\n"
        response += "üèîÔ∏è **N√∫i r·ª´ng**: ƒê√† L·∫°t, Sapa, H√† Giang\n"
        response += "üèõÔ∏è **VƒÉn h√≥a**: H√† N·ªôi, Hu·∫ø, H·ªôi An\n"
        response += "üåÜ **ƒê√¥ th·ªã**: TP.HCM, C·∫ßn Th∆°\n\n"
        response += "üëá **Ch·ªçn ƒëi·ªÉm ƒë·∫øn b√™n d∆∞·ªõi ho·∫∑c g√µ t√™n n∆°i b·∫°n mu·ªën ƒëi:**"
        
        # Popular destinations as options
        options = [
            "üèñÔ∏è ƒê√† N·∫µng",
            "üèîÔ∏è ƒê√† L·∫°t", 
            "üèùÔ∏è Ph√∫ Qu·ªëc",
            "üåÜ H√† N·ªôi",
            "üèõÔ∏è Hu·∫ø"
        ]
        
        return {
            "reply": response,
            "ui_type": "options",
            "ui_data": {
                "title": "Ch·ªçn ƒëi·ªÉm ƒë·∫øn",
                "options": options,
                "awaiting_destination": True
            },
            "status": "partial",
            "context": context.to_dict()
        }
    
    async def _create_location_intro_response(
        self,
        location: str,
        context
    ) -> Dict[str, Any]:
        """Create a friendly intro for a location and gather trip details"""
        
        # Use global LOCATION_HIGHLIGHTS
        loc_key = location.lower()
        loc_info = LOCATION_HIGHLIGHTS.get(loc_key, LOCATION_HIGHLIGHTS["default"])
        
        # Map from global format to local format
        info = {
            "emoji": loc_info.get("icon", "üåç"),
            "tagline": loc_info.get("tagline", "ƒëi·ªÉm ƒë·∫øn h·∫•p d·∫´n"),
            "highlights": loc_info.get("highlights", "").split(", ") if isinstance(loc_info.get("highlights"), str) else [],
            "best_for": ", ".join(loc_info.get("tags", ["kh√°m ph√°"]))
        }
        
        # Build response
        response = f"{info['emoji']} **{location}** - {info['tagline']}!\n\n"
        
        if info['highlights']:
            response += "üìç ƒêi·ªÉm n·ªïi b·∫≠t: " + ", ".join(info['highlights'][:3]) + "\n"
        
        response += f"‚ú® Ph√π h·ª£p cho: {info['best_for']}\n\n"
        
        response += "---\n\n"
        response += "ƒê·ªÉ t√¥i l√™n k·∫ø ho·∫°ch t·ªët nh·∫•t cho b·∫°n, cho t√¥i bi·∫øt th√™m:\n\n"
        response += "1Ô∏è‚É£ **B·∫°n ƒëi m·∫•y ng√†y?** (VD: 3 ng√†y 2 ƒë√™m)\n"
        response += "2Ô∏è‚É£ **ƒêi m·∫•y ng∆∞·ªùi?**\n"
        response += "3Ô∏è‚É£ **Ng√¢n s√°ch kho·∫£ng bao nhi√™u?** (VD: 5 tri·ªáu/ng∆∞·ªùi)\n"
        response += "4Ô∏è‚É£ **B·∫°n th√≠ch g√¨?** (bi·ªÉn, n√∫i, ·∫©m th·ª±c, vƒÉn h√≥a...)\n\n"
        response += f"üí° _Ho·∫∑c n√≥i: \"L√™n l·ªãch tr√¨nh {location} 3 ng√†y 5 tri·ªáu\"_"
        
        # Store location in context for follow-up
        context.destination = location
        
        # Generate GenUI options for quick selection
        options = [
            f"L√™n l·ªãch tr√¨nh {location} 2 ng√†y",
            f"L√™n l·ªãch tr√¨nh {location} 3 ng√†y",
            f"L√™n l·ªãch tr√¨nh {location} 5 ng√†y",
            f"T√¨m kh√°ch s·∫°n {location}",
            f"ƒê·ªãa ƒëi·ªÉm tham quan {location}"
        ]
        
        return {
            "reply": response,
            "ui_type": "options",
            "ui_data": {
                "title": "Ch·ªçn nhanh",
                "options": options,
                "location": location,
                "awaiting_details": True
            },
            "status": "partial",
            "context": context.to_dict()
        }
    
    def _execute_plan_subset(self, tasks: List, original_query: str, aggregated_data: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Execute a subset of tasks (for streaming)
        
        Args:
            tasks: List of SubTask to execute
            original_query: Original user message
            aggregated_data: Data from previous groups (spots, hotels, food) for dependencies
        """
        results = {}
        aggregated_data = aggregated_data or {}
        
        for task in tasks:
            try:
                start = time.time()
                task_type = task.task_type.value
                
                if task_type not in self.experts:
                    logger.warning(f"‚ö†Ô∏è No expert for {task_type}")
                    results[task.task_id] = None
                    continue
                
                expert = self.experts[task_type]
                
                # Prepare parameters like _execute_plan() does
                parameters = dict(task.parameters)
                if original_query:
                    parameters["original_query"] = original_query
                
                # CRITICAL: Pass data from previous groups for tasks that have dependencies
                # This is essential for itinerary and cost experts to work correctly
                if task.depends_on:
                    logger.info(f"   üì¶ Task {task.task_id} depends on: {task.depends_on}")
                    
                    # Pass spots data if dependency includes spots
                    if any("spots" in dep for dep in task.depends_on):
                        if aggregated_data.get("spots"):
                            parameters["spots_data"] = aggregated_data["spots"]
                            logger.info(f"   ‚úì Passing {len(aggregated_data['spots'])} spots to {task.task_id}")
                    
                    # Pass food data if dependency includes food
                    if any("food" in dep for dep in task.depends_on):
                        if aggregated_data.get("food"):
                            parameters["food_data"] = aggregated_data["food"]
                            logger.info(f"   ‚úì Passing {len(aggregated_data['food'])} foods to {task.task_id}")
                    
                    # Pass hotel data if dependency includes hotel
                    if any("hotel" in dep for dep in task.depends_on):
                        if aggregated_data.get("hotels"):
                            parameters["hotel_data"] = aggregated_data["hotels"]
                            logger.info(f"   ‚úì Passing {len(aggregated_data['hotels'])} hotels to {task.task_id}")
                    
                    # Pass itinerary data for cost calculation
                    if any("itinerary" in dep for dep in task.depends_on):
                        if aggregated_data.get("itinerary"):
                            parameters["itinerary_data"] = aggregated_data["itinerary"]
                            logger.info(f"   ‚úì Passing itinerary to {task.task_id}")
                
                # Execute expert
                result = expert.execute(task.query, parameters)
                
                elapsed = int((time.time() - start) * 1000)
                count = len(result.data) if result.data else 0
                logger.info(f"   ‚úì {task.task_id}: {count} results, {elapsed}ms, success={result.success}")
                
                results[task.task_id] = result
                
            except Exception as e:
                logger.error(f"‚ùå Task {task.task_id} failed: {e}")
                results[task.task_id] = None
        
        return results
    
    def _get_last_user_message(self, messages: List[Dict]) -> Optional[str]:
        """Extract last user message from conversation"""
        for msg in reversed(messages):
            if msg.get("role") == "user":
                return msg.get("content", "")
        return None
    
    # ============================================================
    # STATE GUARD: Ch·∫∑n Intent "nh·∫£y b∆∞·ªõc" d·ª±a tr√™n workflow_state
    # ============================================================
    
    def _validate_intent_flow(self, multi_intent, enhanced_context) -> tuple:
        """
        StateGuard: L·ªçc danh s√°ch intents d·ª±a tr√™n workflow_state hi·ªán t·∫°i.
        
        Returns:
            (valid_intents: List[str], blocked_reasons: List[str])
        """
        valid_intents = []
        blocked_reasons = []
        current_state = getattr(enhanced_context, 'workflow_state', 'INITIAL')
        
        # Get all intents: primary + sub_intents
        all_intents = [multi_intent.primary_intent] + (multi_intent.sub_intents or [])
        
        for intent in all_intents:
            rule = self.INTENT_DEPENDENCIES.get(intent)
            
            # Kh√¥ng c√≥ rule = cho ph√©p t·ª± do
            if not rule:
                valid_intents.append(intent)
                continue
            
            # Ki·ªÉm tra State
            allowed_states = rule.get("required_states", [])
            state_ok = current_state in allowed_states if allowed_states else True
            
            # Ki·ªÉm tra required fields trong context
            required_fields = rule.get("required_fields", [])
            fields_ok = all(
                getattr(enhanced_context, field, None) is not None
                for field in required_fields
            )
            
            if state_ok and fields_ok:
                valid_intents.append(intent)
            else:
                blocked_reasons.append({
                    "intent": intent,
                    "reason": rule.get("error_msg"),
                    "action": rule.get("error_action")
                })
                logger.info(f"üö´ StateGuard blocked: {intent} (state={current_state}, fields_ok={fields_ok})")
        
        return valid_intents, blocked_reasons
    
    def _generate_state_guard_response(self, blocked_reasons: list, enhanced_context) -> dict:
        """
        T·∫°o response th√¥ng minh khi Intent b·ªã ch·∫∑n.
        D√πng LLM ƒë·ªÉ gi·∫£i th√≠ch kh√©o l√©o thay v√¨ template c·ª©ng.
        """
        if not blocked_reasons:
            return None
        
        # L·∫•y l√Ω do ƒë·∫ßu ti√™n (∆∞u ti√™n)
        first_block = blocked_reasons[0]
        error_msg = first_block.get("reason", "H√£y ho√†n th√†nh c√°c b∆∞·ªõc tr∆∞·ªõc nh√©!")
        error_action = first_block.get("action")
        
        # X√°c ƒë·ªãnh UI ph√π h·ª£p
        ui_type = "options"
        actions = []
        
        if error_action == "prompt_hotel":
            actions = [
                {"label": "üè® T√¨m kh√°ch s·∫°n", "action": "find_hotel"},
                {"label": "üìã Xem l·ªãch tr√¨nh", "action": "view_itinerary"}
            ]
        elif error_action == "prompt_destination":
            actions = [
                {"label": "üó∫Ô∏è G·ª£i √Ω ƒëi·ªÉm ƒë·∫øn", "action": "suggest_destinations"}
            ]
        
        return {
            "reply": error_msg,
            "ui_type": ui_type,
            "ui_data": {"actions": actions} if actions else {},
            "status": "blocked",
            "workflow_state": enhanced_context.workflow_state,
            "context": enhanced_context.to_dict()
        }
    
    def _should_stay_in_builder(self, multi_intent, enhanced_context, user_message: str) -> bool:
        """
        Ki·ªÉm tra xem user c√≥ ƒëang trong Itinerary Builder kh√¥ng.
        N·∫øu c√≥, ∆∞u ti√™n gi·ªØ h·ªç ·ªü l·∫°i thay v√¨ nh·∫£y sang Intent kh√°c.
        """
        # ƒêang trong builder?
        if not enhanced_context.itinerary_builder:
            return False
        
        current_state = getattr(enhanced_context, 'workflow_state', 'INITIAL')
        
        # State ƒëang l√† CHOOSING_SPOTS ho·∫∑c CHOOSING_HOTEL
        if current_state in ["CHOOSING_SPOTS", "CHOOSING_HOTEL"]:
            # Ch·ªâ tho√°t builder n·∫øu user Y√äU C·∫¶U ƒê√çCH DANH
            explicit_exit_keywords = [
                "h·ªßy l·ªãch", "h·ªßy trip", "kh√¥ng c·∫ßn n·ªØa", "b·ªè qua", 
                "reset", "l√†m l·∫°i t·ª´ ƒë·∫ßu", "ƒë·ªïi ƒëi·ªÉm ƒë·∫øn"
            ]
            lower_msg = user_message.lower()
            
            if any(kw in lower_msg for kw in explicit_exit_keywords):
                logger.info(f"üö™ User explicitly exiting builder: {user_message[:30]}")
                return False
            
            # M·∫∑c ƒë·ªãnh: GI·ªÆ user ·ªü builder
            return True
        
        return False
    
    def _is_finalize_signal(self, user_message: str) -> bool:
        """
        Nh·∫≠n di·ªán c√°c t√≠n hi·ªáu "ho√†n t·∫•t b∆∞·ªõc hi·ªán t·∫°i" t·ª´ user.
        D√πng k·∫øt h·ª£p keywords ƒë∆°n gi·∫£n + LLM flow_action.
        """
        lower_msg = user_message.lower().strip()
        
        finalize_signals = [
            "xong", "done", "ti·∫øp", "ti·∫øp t·ª•c", "next", 
            "ƒë∆∞·ª£c r·ªìi", "ok r·ªìi", "oke", "ƒë∆∞·ª£c", "ti·∫øp ƒëi",
            "chuy·ªÉn sang", "b∆∞·ªõc ti·∫øp", "ho√†n t·∫•t", "k·∫øt th√∫c"
        ]
        
        # Check exact match ho·∫∑c starts with
        for signal in finalize_signals:
            if lower_msg == signal or lower_msg.startswith(signal + " "):
                return True
        
        return False
    
    def _is_backtrack_signal(self, user_message: str) -> bool:
        """
        Nh·∫≠n di·ªán t√≠n hi·ªáu user mu·ªën QUAY L·∫†I ch·ªânh s·ª≠a l·ªãch tr√¨nh.
        V√≠ d·ª•: "th√™m ƒë·ªãa ƒëi·ªÉm", "s·ª≠a l·∫°i ng√†y 2", "th√™m 1 ch·ªó check-in", etc.
        """
        lower_msg = user_message.lower().strip()
        
        backtrack_signals = [
            # Th√™m ƒë·ªãa ƒëi·ªÉm
            "th√™m ƒë·ªãa ƒëi·ªÉm", "th√™m ƒëi·ªÉm", "th√™m ch·ªó", "th√™m spot",
            "th√™m cho m√¨nh", "th√™m 1", "th√™m m·ªôt", "add more",
            # S·ª≠a l·ªãch
            "s·ª≠a l·ªãch", "ch·ªânh l·ªãch", "thay ƒë·ªïi", "ƒë·ªïi l·∫°i", "modify",
            # Quay l·∫°i
            "quay l·∫°i", "back", "go back", "tr·ªü l·∫°i",
            # B·ªè / thay th·∫ø
            "b·ªè", "x√≥a", "remove", "thay b·∫±ng", "ƒë·ªïi sang"
        ]
        
        # Check substring match
        for signal in backtrack_signals:
            if signal in lower_msg:
                return True
        
        # Check for day modification patterns
        import re
        day_modify_pattern = r"(ng√†y\s*\d+|day\s*\d+).*(th√™m|s·ª≠a|x√≥a|b·ªè|ƒë·ªïi)"
        if re.search(day_modify_pattern, lower_msg):
            return True
        
        return False

    def _restore_context(self, context: Dict = None) -> ConversationContext:
        """Restore or create conversation context (legacy)"""
        if not context:
            return ConversationContext()
        
        return ConversationContext(
            destination=context.get("destination"),
            duration=context.get("duration"),
            budget=context.get("budget"),
            budget_level=context.get("budget_level"),
            people_count=context.get("people_count", 1),
            interests=context.get("interests", []),
            last_intent=context.get("last_intent"),
            selected_hotel=context.get("selected_hotel")
        )
    
    def _restore_enhanced_context(self, context: Dict = None):
        """Restore or create enhanced conversation context with memory"""
        if not context:
            return self.EnhancedConversationContext()
        
        enhanced = self.EnhancedConversationContext(
            destination=context.get("destination"),
            duration=context.get("duration"),
            budget=context.get("budget"),
            budget_level=context.get("budget_level"),
            people_count=context.get("people_count", 1),
            companion_type=context.get("companion_type"),
            interests=context.get("interests", []),
            last_intent=context.get("last_intent"),
            selected_hotel=context.get("selected_hotel"),
            selected_hotel_price=context.get("selected_hotel_price"),
            answered_intents=context.get("answered_intents", []),
            conversation_summary=context.get("conversation_summary", ""),
            # Restore last search results for follow-up queries
            last_spots=context.get("last_spots", []),
            last_hotels=context.get("last_hotels", []),
            last_foods=context.get("last_foods", []),
            # Restore workflow state machine fields
            workflow_state=context.get("workflow_state", "INITIAL"),
            spots_selected_per_day=context.get("spots_selected_per_day", {}),
            hotels_selected_per_day=context.get("hotels_selected_per_day", {})
        )
        
        # Restore itinerary builder state
        if "itinerary_builder" in context:
            enhanced.itinerary_builder = context["itinerary_builder"]
        
        # Restore saved itinerary for recall
        if "last_itinerary" in context:
            enhanced.last_itinerary = context["last_itinerary"]
        
        # Restore chat history if available
        if "chat_history" in context:
            from app.services.conversation_memory import ChatMessage
            enhanced.chat_history = [
                ChatMessage(**msg) if isinstance(msg, dict) else msg
                for msg in context["chat_history"][-10:]  # Keep last 10
            ]
        
        return enhanced
    
    def _execute_plan(self, plan, original_query: str = None) -> Dict[str, Any]:
        """Execute plan tasks using experts
        
        Args:
            plan: ExecutionPlan with tasks to execute
            original_query: Original user message (to preserve semantic intent)
        """
        results = {}
        
        # Get parallel task groups
        task_groups = plan.get_parallel_tasks()
        
        for group in task_groups:
            # Execute tasks in this group
            # (In a real implementation, these could run in parallel)
            for task in group:
                task_type = task.task_type.value
                
                if task_type in self.experts:
                    expert = self.experts[task_type]
                    
                    # Add data from previous tasks if this task depends on them
                    parameters = dict(task.parameters)
                    
                    # CRITICAL: Add original user query to preserve semantic intent
                    if original_query:
                        parameters["original_query"] = original_query
                    
                    for dep_id in task.depends_on:
                        if dep_id in results:
                            # Pass data from dependency
                            dep_result = results[dep_id]
                            if "spots" in dep_id:
                                parameters["spots_data"] = dep_result.data
                            elif "food" in dep_id:
                                parameters["food_data"] = dep_result.data
                            elif "hotel" in dep_id:
                                parameters["hotel_data"] = dep_result.data
                    
                    # Execute expert
                    result = expert.execute(task.query, parameters)
                    results[task.task_id] = result
                    
                    logger.info(f"   ‚úì {task.task_id}: {len(result.data)} results, {result.execution_time_ms}ms")
        
        return results
    
    def _aggregate_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Aggregate results from all experts"""
        aggregated = {
            "spots": [],
            "hotels": [],
            "food": [],
            "itinerary": [],
            "costs": None,
            "general_info": [],
            "summaries": []
        }
        
        for task_id, result in results.items():
            if not result or not result.success:
                continue
            
            # Categorize results
            if "spots" in task_id:
                aggregated["spots"].extend(result.data)
            elif "hotel" in task_id:
                aggregated["hotels"].extend(result.data)
            elif "food" in task_id:
                aggregated["food"].extend(result.data)
            elif "itinerary" in task_id:
                aggregated["itinerary"] = result.data
            elif "cost" in task_id:
                aggregated["costs"] = result.data[0] if result.data else None
            elif "info" in task_id:
                aggregated["general_info"].extend(result.data)
            
            if result.summary:
                aggregated["summaries"].append(result.summary)
        
        return aggregated
    
    def _generate_response(
        self,
        intent,
        aggregated: Dict[str, Any],
        context: ConversationContext,
        original_query: str
    ) -> Dict[str, Any]:
        """Generate final response based on intent and aggregated data"""
        
        intent_type = intent.intent
        
        # Route to appropriate response generator
        if intent_type == "plan_trip":
            return self._generate_planning_response(intent, aggregated, context)
        elif intent_type == "find_hotel":
            return self._generate_hotel_response(intent, aggregated, context)
        elif intent_type == "find_food":
            return self._generate_food_response(intent, aggregated, context)
        elif intent_type == "find_spot":
            return self._generate_spot_response(intent, aggregated, context)
        else:
            return self._generate_general_response(intent, aggregated, context, original_query)
    
    def _generate_planning_response(self, intent, aggregated, context) -> Dict:
        """Generate response for trip planning"""
        
        location = intent.location or context.destination or "ƒë·ªãa ƒëi·ªÉm"
        duration = intent.duration or context.duration or 2
        
        # Build reply
        reply_parts = []
        
        # Header
        reply_parts.append(f"üóìÔ∏è **L·ªãch tr√¨nh {duration} ng√†y t·∫°i {location}**\n")
        
        # Itinerary
        if aggregated["itinerary"]:
            for day in aggregated["itinerary"]:
                day_num = day.get("day", "?")
                title = day.get("title", f"Ng√†y {day_num}")
                reply_parts.append(f"\n**{title}**")
                
                for activity in day.get("activities", []):
                    time_str = activity.get("time", "")
                    activity_name = activity.get("activity", "")
                    reply_parts.append(f"- {time_str}: {activity_name}")
        else:
            # Show spots instead
            reply_parts.append("\n**ƒê·ªãa ƒëi·ªÉm g·ª£i √Ω:**")
            for spot in aggregated["spots"][:5]:
                name = spot.get("name", "?")
                rating = spot.get("rating", 0)
                reply_parts.append(f"- ‚≠ê {name} ({rating}/5)")
        
        # Costs
        if aggregated["costs"]:
            total = aggregated["costs"].get("total", 0)
            reply_parts.append(f"\nüí∞ **T·ªïng chi ph√≠ d·ª± ki·∫øn:** {total:,.0f} VNƒê")
        
        # Hotels
        if aggregated["hotels"]:
            reply_parts.append("\nüè® **Kh√°ch s·∫°n g·ª£i √Ω:**")
            for hotel in aggregated["hotels"][:3]:
                name = hotel.get("name", "?")
                price = hotel.get("price_formatted", "")
                reply_parts.append(f"- {name} - {price}")
        
        # UI options
        ui_options = [
            "üìù Xem l·ªãch tr√¨nh chi ti·∫øt",
            "üè® ƒê·ªïi kh√°ch s·∫°n kh√°c",
            "üí∞ T√≠nh l·∫°i chi ph√≠",
            "üîÑ L√†m l·∫°i v·ªõi ƒëi·ªÅu ki·ªán kh√°c"
        ]
        
        return {
            "reply": "\n".join(reply_parts),
            "ui_type": "options",
            "ui_data": {"options": ui_options},
            "intent": "plan_trip",
            "data": {
                "itinerary": aggregated["itinerary"],
                "spots": aggregated["spots"][:5],
                "hotels": aggregated["hotels"][:3],
                "costs": aggregated["costs"]
            }
        }
    
    def _generate_hotel_response(self, intent, aggregated, context) -> Dict:
        """Generate response for hotel search"""
        
        hotels = aggregated["hotels"]
        location = intent.location or context.destination or "khu v·ª±c"
        
        if not hotels:
            return {
                "reply": f"‚ùå Kh√¥ng t√¨m th·∫•y kh√°ch s·∫°n ph√π h·ª£p ·ªü {location}. B·∫°n th·ª≠ t√¨m v·ªõi ƒëi·ªÅu ki·ªán kh√°c nh√©!",
                "ui_type": "none",
                "intent": "find_hotel"
            }
        
        reply_parts = [f"üè® **Kh√°ch s·∫°n t·∫°i {location}**\n"]
        
        for i, hotel in enumerate(hotels[:5], 1):
            name = hotel.get("name", "?")
            price = hotel.get("price_formatted", "N/A")
            rating = hotel.get("rating", 0)
            facilities = hotel.get("facilities", "")[:50]
            
            reply_parts.append(f"**{i}. {name}**")
            reply_parts.append(f"   üíµ {price} | ‚≠ê {rating}/10")
            if facilities:
                reply_parts.append(f"   üè∑Ô∏è {facilities}...")
            reply_parts.append("")
        
        # UI options - hotel cards
        hotel_options = [
            {"label": h.get("name"), "value": h.get("id"), "price": h.get("price_formatted")}
            for h in hotels[:5]
        ]
        
        return {
            "reply": "\n".join(reply_parts),
            "ui_type": "hotel_cards",
            "ui_data": {"hotels": hotel_options},
            "intent": "find_hotel",
            "data": {"hotels": hotels[:5]}
        }
    
    def _generate_food_response(self, intent, aggregated, context) -> Dict:
        """Generate response for food search"""
        
        foods = aggregated["food"]
        location = intent.location or context.destination or "khu v·ª±c"
        
        if not foods:
            return {
                "reply": f"üçú M√¨nh ch∆∞a c√≥ nhi·ªÅu th√¥ng tin v·ªÅ qu√°n ƒÉn ·ªü {location}. B·∫°n th·ª≠ h·ªèi c·ª• th·ªÉ h∆°n nh√©!",
                "ui_type": "none",
                "intent": "find_food"
            }
        
        reply_parts = [f"üçú **·∫®m th·ª±c {location}**\n"]
        
        for food in foods[:5]:
            if food.get("type") == "recommendation":
                # Regional specialty
                dishes = food.get("dishes", [])
                reply_parts.append(f"üåü **M√≥n ƒë·∫∑c s·∫£n n√™n th·ª≠:**")
                reply_parts.append(f"   {', '.join(dishes[:5])}")
            else:
                name = food.get("name", "?")
                desc = food.get("description", "")[:80]
                rating = food.get("rating", 0)
                
                reply_parts.append(f"‚Ä¢ **{name}** (‚≠ê {rating})")
                if desc:
                    reply_parts.append(f"  {desc}")
            reply_parts.append("")
        
        return {
            "reply": "\n".join(reply_parts),
            "ui_type": "none",
            "intent": "find_food",
            "data": {"food": foods[:5]}
        }
    
    def _generate_spot_response(self, intent, aggregated, context) -> Dict:
        """Generate response for spot search"""
        
        spots = aggregated["spots"]
        location = intent.location or context.destination or "Vi·ªát Nam"
        
        if not spots:
            return {
                "reply": f"üîç Kh√¥ng t√¨m th·∫•y ƒë·ªãa ƒëi·ªÉm ph√π h·ª£p ·ªü {location}. B·∫°n th·ª≠ t·ª´ kh√≥a kh√°c nh√©!",
                "ui_type": "none",
                "intent": "find_spot"
            }
        
        reply_parts = [f"üìç **ƒê·ªãa ƒëi·ªÉm du l·ªãch t·∫°i {location}**\n"]
        
        for i, spot in enumerate(spots[:6], 1):
            name = spot.get("name", "?")
            rating = spot.get("rating", 0)
            desc = spot.get("description", "")[:100]
            
            reply_parts.append(f"**{i}. {name}** ‚≠ê {rating}")
            if desc:
                reply_parts.append(f"   {desc}")
            reply_parts.append("")
        
        # UI - spot cards
        spot_options = [
            {"label": s.get("name"), "value": s.get("id"), "image": s.get("image")}
            for s in spots[:6]
        ]
        
        return {
            "reply": "\n".join(reply_parts),
            "ui_type": "spot_cards",
            "ui_data": {"spots": spot_options},
            "intent": "find_spot",
            "data": {"spots": spots[:6]}
        }
    
    def _generate_general_response(self, intent, aggregated, context, query) -> Dict:
        """Generate response for general questions"""
        
        # Use LLM to generate response
        if self.llm:
            try:
                # Build context
                location = intent.location or context.destination
                location_text = f" v·ªÅ {location}" if location else ""
                
                prompt = f"""B·∫°n l√† h∆∞·ªõng d·∫´n vi√™n du l·ªãch Vi·ªát Nam.
                
C√¢u h·ªèi: "{query}"

H√£y tr·∫£ l·ªùi ng·∫Øn g·ªçn, h·ªØu √≠ch{location_text}.
N·∫øu c√¢u h·ªèi li√™n quan ƒë·∫øn ƒë·ªãa ƒëi·ªÉm c·ª• th·ªÉ, h√£y g·ª£i √Ω c√°c ho·∫°t ƒë·ªông ph√π h·ª£p.
"""
                response = self.llm.complete(prompt, temperature=0.7, max_tokens=500)
                
                return {
                    "reply": response,
                    "ui_type": "none",
                    "intent": "general_qa"
                }
                
            except Exception as e:
                logger.error(f"‚ùå LLM response error: {e}")
        
        # Fallback response
        return {
            "reply": "M√¨nh c√≥ th·ªÉ gi√∫p b·∫°n l√™n k·∫ø ho·∫°ch du l·ªãch, t√¨m kh√°ch s·∫°n, ƒë·ªãa ƒëi·ªÉm tham quan v√† qu√°n ƒÉn. B·∫°n mu·ªën ƒëi ƒë√¢u?",
            "ui_type": "options",
            "ui_data": {
                "options": [
                    "üèùÔ∏è G·ª£i √Ω ƒë·ªãa ƒëi·ªÉm hot",
                    "üóìÔ∏è L√™n l·ªãch tr√¨nh",
                    "üè® T√¨m kh√°ch s·∫°n",
                    "üçú G·ª£i √Ω ·∫©m th·ª±c"
                ]
            },
            "intent": "general_qa"
        }
    
    def _error_response(self, error_message: str) -> Dict:
        """Generate error response"""
        return {
            "reply": f"‚ö†Ô∏è Xin l·ªói, c√≥ l·ªói x·∫£y ra: {error_message}. B·∫°n th·ª≠ l·∫°i nh√©!",
            "ui_type": "none",
            "intent": "error",
            "error": error_message
        }
    
    def _determine_ui_type(self, answered_sections: List[str], aggregated: Dict) -> str:
        """Determine UI type based on answered sections"""
        if "plan_trip" in answered_sections and aggregated.get("itinerary"):
            return "itinerary"
        elif len(answered_sections) > 1:
            return "comprehensive"
        elif "find_hotel" in answered_sections:
            return "hotel_cards"
        elif "find_spot" in answered_sections:
            return "spot_cards"
        elif "find_food" in answered_sections:
            return "food_cards"
        else:
            return "none"
    
    def _build_ui_data(self, answered_sections: List[str], aggregated: Dict) -> Dict:
        """Build UI data for answered sections"""
        ui_data = {}
        
        if "find_hotel" in answered_sections and aggregated.get("hotels"):
            ui_data["hotels"] = aggregated["hotels"][:5]
        
        if "find_spot" in answered_sections and aggregated.get("spots"):
            # For spot_cards UI type, frontend expects data in 'options'
            # For comprehensive UI type, frontend expects data in 'spots'
            spots_data = aggregated["spots"][:6]
            if len(answered_sections) == 1:
                # Single intent - use options for spot_cards
                ui_data["options"] = spots_data
            else:
                # Multi-intent - use spots for comprehensive
                ui_data["spots"] = spots_data
        
        if "find_food" in answered_sections and aggregated.get("food"):
            ui_data["food"] = aggregated["food"][:5]
        
        if "plan_trip" in answered_sections:
            if aggregated.get("itinerary"):
                ui_data["itinerary"] = aggregated["itinerary"]
            if aggregated.get("costs"):
                ui_data["costs"] = aggregated["costs"]
        
        return ui_data
    
    def _generate_clarification_request(
        self,
        multi_intent,
        unanswered_intents: List[tuple],
        context
    ) -> str:
        """Generate friendly clarification request"""
        
        lines = ["üëã Xin ch√†o! M√¨nh c√≥ th·ªÉ gi√∫p b·∫°n l√™n k·∫ø ho·∫°ch du l·ªãch nh√©!"]
        lines.append("")
        
        # Ask for missing info
        missing_msg = context.get_missing_params_message(multi_intent.primary_intent)
        if missing_msg:
            lines.append(missing_msg)
        else:
            lines.append("B·∫°n mu·ªën ƒëi ƒë√¢u v√† trong bao l√¢u?")
        
        return "\n".join(lines)
    
    def _generate_clarification_options(self, context) -> Dict:
        """Generate options for clarification"""
        options = []
        
        if not context.destination:
            options.extend([
                "üèñÔ∏è ƒê√† N·∫µng",
                "üèîÔ∏è ƒê√† L·∫°t",
                "üèùÔ∏è Ph√∫ Qu·ªëc",
                "üåÜ H·ªì Ch√≠ Minh"
            ])
        elif not context.duration:
            options.extend([
                "2 ng√†y 1 ƒë√™m",
                "3 ng√†y 2 ƒë√™m",
                "4-5 ng√†y"
            ])
        
        return {"options": options} if options else {}


# Factory function
def create_master_controller() -> MasterController:
    """Create MasterController instance"""
    return MasterController()
